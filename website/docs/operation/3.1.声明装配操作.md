## 3.1.1.声明装配操作

**在属性上直接声明**

一般情况下，可以使用 `@Assemble` 在某个 key 字段上声明一次装配操作：

~~~java
public class Student {
    @Assemble(container = "student", props = @Mapping(src = "studentName", ref = "name"))
    private Integer id;
    private String name;
}
~~~

上述配置表示这样一个操作：

1. 使用 `id` 字段的值；
2. 去 `namespace` 为 `student` 的数据源容器中获取数据源对象；
3. 获得与 `id` 字段值对应的数据后，将数据源对象中的 `studentName` 字段值，映射到 `name` 字段上；

如果 src 和 ref 指向的字段都一样，也可以直接使用 `value` 属性同时指定，比如：

~~~java
public class Student {
    @Assemble(container = "student", props = @Mapping("name")) // source.name -> target.name
    private Integer id;
    private String name;
}
~~~

**在类上声明**

有时候为了保持代码的整洁，或者不方便直接修改父类，我们也可以不直接在属性上添加注解，而是在类上添加注解：

~~~java
// 直接声明
@Assemble(key = "id", container = "student", props = @Mapping(src = "studentName", ref = "name"))
public class Student {
    private Integer id;
    private String name;
}
~~~

与直接在属性上声明不同，需要通过 `key` 属性绑定对应的 `key` 字段。

:::tip

- 在父类、父类的属性中声明的操作，子类也会一并继承；
- `key` 属性默认支持通过 `xx.xx.xx` 格式的链式操作符访问嵌套对象的属性；

:::

## 3.1.2.声明多重装配

有时候，我们会需要在一个 `key` 上声明多次装配操作，这也是允许的：

~~~java
public class UserVO {
    @Assemble(container = "user", props = @Mapping(src = "role", ref = "role"), groups = "admin")
    @Assemble(container = "user", props = @Mapping(src = "name", ref = "name"), groups = {"base", "admin"})
    private Integer id;
    private String name;
    private String role;
}
~~~

:::tip

不必担心多次查库，默认的执行器 `DisorderedBeanOperationExecutor` 会将容器相同的操作汇总在一起再执行，保证尽可能少的减少数据源容器的调用次数。

:::

## 3.1.3.动态表达式

在 `@Assemble` 注解的 `container` 属性中，可以像 `@Value` 那样格式引用配置文件的属性：

~~~java
public class Foo {
    @Assemble(container = "${custom.namespace}")
    private String name;
    private String alias;
}
~~~

支持 SpEL 表达式，并且默认可以通过 `@beanName` 的方式引用 `bean`：

~~~java
public class Foo {
    @Assemble(container = "@customContainer")
    private String name;
    private String alias;
}
~~~

该表达式的执行结果可以直接是容器对象，也可以是容器的命名空间。

:::tip

仅在 spring 环境中支持

:::

## 3.1.4.指定容器提供者

同样的，我们也可以通过在注解中通过 `beanName` 以及 `class` 指定要使用的容器提供者：

~~~java
public class Foo {
    @Assemble(container = "${custom.namespace}", containerProviderName = "expressionContainerProvider")
    private String name;
    private String alias;
}
~~~

该示例指定操作要通过 `beanName` 为 `expressionContainerProvider` 的提供者获取容器，具体参见[容器提供者](./../datasource/2.8.容器提供者.md)一节。

:::tip

仅在 spring 环境中支持

:::

## 3.1.5.指定装配操作处理器

装配操作处理器 `AssembleOperateHandler` 是整个装配过程中实际完成属性读写的组件，相当于 Jackson 中的 `Serializer` 和 `Deserializer`。与 Jackson 相同，如果我们需要处理一些具有特殊数据结构、或者特殊的填充逻辑的 JavaBean ，就需要更换不同的装配操作处理器。

处理器有三种实现：

- `OneToOneAssembleOperationHandler`：一对一装配操作处理器，也是默认的装配处理器；
- `OneToManyAssembleOperationHandler`：一对多装配操作处理器；
- `ManyToManyAssembleOperationHandler`：多对多装配操作处理器；

和其他组件一样，用户可以实现 `AssembleOperationHandler` 接口，将其声明到 spring 上下文中完成自动注册，或者手动获取全局配置类进行注册。

用户可以在 `@Assemble` 注解的 `handler` 属性或者 `handlerName` 属性中，指定本次装配操作要使用的处理器。比如：

~~~java
public class Foo {
    @Assemble(container = "${custom.namespace}", handlerName = "oneToOneReflexAssembleOperationHandler")
    private String name;
    private String alias;
}
~~~

关于另外两种处理器的使用，请参见一对多装配和多对多装配一节。