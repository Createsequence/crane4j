## lambda容器

我们可以通过 `LambdaContainer` 将输入 `Collection` 集合并返回 `Map` 集合的任何 `lambda` 表达式定义为容器：

~~~java
// 定义 lambda 容器，接受 key 值，并返回按 key 分组的数据源对象
Container<String> container = LambdaContainer.forLambda(
    namespace, keys -> keys.stream().collect(Collectors.toMap(Function.identity(), Function.identity()))
);

// 获取全局上下文并注册容器
Crane4jGlobalConfiguration configuration = SpringUtils.getBean(Crane4jGlobalConfiguration.class);
configuration.registerContainer(container);
~~~

其中，方法数据源的函数式接口 `DataProvider` 也内置了一些方便的工厂方法：

~~~java
// 固定返回某个集合
DataProvider<Integer, ?> provider1 = DataProvider.fixed(Collections.emptyMap());
ambdaContainer.forLambda(namespace, provider1);

// 总是返回空集合
DataProvider<Integer, ?> provider2 = DataProvider.empty();
ambdaContainer.forLambda(namespace, provider2);
~~~

与常量数据源一样，我们同样也通过获得 `Crane4jGlobalConfiguration` 方法手动注册该数据源容器，在非 spring 环境中，同样需要保证注册的配置类为配置解析器 `BeanOperationsParser` 所使用的实例。

