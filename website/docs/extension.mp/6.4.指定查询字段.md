## 概述

表达式中的 `container()` 函数本质上即 `MpMethodContainerProvider` 中的 `container()` 重载方法。

该方法存着四种重载，因此在表达式中可以通过四种不同的写法，分别指定查询的外键字段与查询的字段。

假设我们现在有数据库表映射对象如下：

~~~java
@TableName("foo")
public class Foo {
    @TableId
    private Integer id;
    @TableField("user_name")
    private String userName;
    @TableField("user_age")
    private Integer userAge;
}
~~~

并在 Spring 上下文中已有继承 `BaseMapper` 接口的 `FooMapper` 这个 `bean`，其 `beanName` 默认为 `fooMapper`。

## 6.4.1.根据主键查询全部字段

格式为 `container('{mapperName}')`，比如：

~~~java
@Assemble(
    container = "container('fooMapper')",
    containerProvider = MpMethodContainerProvider.class
)
private Integer id;
~~~

上述配置等同于借助 `QueryWrapper` 构建并执行了 `select * from foo where id in ?` 这条 SQL，查询出的数据将会按 `Foo` 中配置主键 `id` 分组。

## 6.4.2.根据主键查询指定字段

格式为 `container('{mapperName}', {{column1}, {column2}...})`，比如：

~~~java
@Assemble(
    container = "container('fooMapper', {'userName', 'userAge'})",
    containerProvider = MpMethodContainerProvider.class
)
private Integer id;
~~~

上述配置等同于借助 `QueryWrapper` 构建并执行了 `select user_name AS userName, user_age AS userAge, id from foo where id in ?` 这条 SQL，查询出的数据将会按 `Foo` 中配置的主键 `id` 分组。

**查询的字段名为对应实体类中的属性名，构建 SQL 时会自动转换成查询 SQL**。

:::tip

`crane4j` 默认将被 `@TableId` 注解的属性作为主键。

:::

## 6.4.3.根据指定外键查询全部字段

格式为 `container('{mapperName}', {query_column}, {{column1}, {column2}...})`，比如：

~~~java
@Assemble(
    container = "container('fooMapper', 'userName')",
    containerProvider = MpMethodContainerProvider.class
)
private String name;
~~~

上述配置等同于借助 `QueryWrapper` 构建并执行了 `select * from foo where user_name in ?` 这条 SQL，查询出的数据将会按用户指定的 `userName` 属性分组。

## 6.4.4.根据指定外键查询指定字段

格式为 `container('{mapperName}', {query_column}, {{column1}, {column2}...})`，比如：

~~~java
@Assemble(
    container = "container('fooMapper', 'userName', {'userAge', 'userSex'})",
    containerProvider = MpMethodContainerProvider.class
)
private String name;
~~~

上述配置等同于借助 `QueryWrapper` 构建并执行了 `select user_age AS userAge, user_name AS userName from foo where user_name in ?` 这条 SQL，查询出的数据将会按用户指定的 `name` 属性分组。

**查询的字段名（包括key字段）为对应实体类中的属性名，构建 SQL 时会自动转换成查询 SQL**。

:::tip

由于查出的数据需要依靠用户指定的外键字段进行分组，然后与 key 值对应，因此当用户指定了查询字段，但是又未包含该外键字段时，将会自动在查询字段后追加该外键字段。

:::

## 6.4.5.指定查询字段 SQL

一般情况下，推荐用户总是以**实体类中的属性名作为查询字段/查询外键**，`crane4j` 会借助 MP 将其转成对应的表字段 SQL。

不过，考虑到有时候确实有自定义查询字段的需求，因此**查询字段**可以直接写自定义 SQL。

比如，现有 `Bean` 如下：

~~~java
@TableName("foo")
public class FooDO {
    @TableId
    private Integer id;
    @TableField("user_name")
    private String name;
    @TableField("user_age")
    private Integer age;
}
~~~

然后装配配置如下：

~~~java
public class FooVO {
    @AssembleByMP(
        container = "container('fooMapper', ['user_name AS name', 'userAge AS age'])"
    )
    private Integer id;
    private String name;
    private String age;
}
~~~

最终执行的 SQL 为：`select user_age AS age, user_name AS name foo where user_name in ?`。

::: warning

需要注意的是，该查询基于 `QueryWrapper` 完成，因此在这种情况可能会查询的表字段与用户的对象不一致，但是又未能自动设置别名的情况。

:::