## 概述

有时候会遇到填充的对象中仍嵌套有其他对象的情况，这种情况下我们需要先将其拆出后再进行填充，而这种 “把 A 字段里嵌套的对象取出并展开” 的操作就称为**拆卸操作**。

嵌套对象可能存在多层，因此在执行填充操作前，会需要先完成拆卸操作将所有嵌套对象展开，再统一的进行装配。

<img src="https://img.xiajibagao.top/image-20230220182831112.png" alt="image-20230220182831112" style="zoom: 50%;" />

:::tip

拆卸操作只是要为了展开嵌套对象，它是嵌套填充的第一步。

:::

## 3.5.1.声明

**在属性上声明**

我们可以直接使用 `@Disassemble` 在某个需要拆卸的属性上声明一次拆卸操作：

~~~java
public class Department {
    private Integer id;
    @Disassemble(type = Employee.class)
    private List<Employee> employees;
}
~~~

如上示例，在填充 `Department` 对象前，将会先把 `Department` 中的 `Employee` 对象全部取出并摊平，若 `Employee` 也有需要拆卸的嵌套对象，则会一并取出摊平，一直递归到所有的对象都平铺为止。

拆卸操作支持处理数组、`Collection` 集合或单个对象。

:::tip

和 `@Assemble` 一样，它同样可以在属性重复声明，不过这并没有什么意义。

:::

**在类上声明**

与 `@Assemble` 一样，`@Disassemble` 同样可以声明在类上：

~~~java
// 直接声明
@Disassemble(key = "employees", type = Employee.class))
public class Department {
    private Integer id;
    private List<Employee> employees;
}
~~~

当声明在类上时，需要通过 `key` 指定需要拆卸的字段。

## 3.5.2.动态类型支持

有些时候无法在编译期就确定要填充的对象类型，则可以不指定 `type`，而是等到执行拆卸时再动态的推断类型：

~~~java
public class Department<T> {
    private Integer id;
    @Disassemble // 无法确定填充类型
    private List<T> employees;
}
~~~

该功能依赖类型解析器 `TypeResolver` 实现，用户可以实现接口替换默认的类型解析器。

## 3.5.3.拆卸操作处理器

与装配操作的装配处理器一样，所有的拆卸操作都依赖拆卸操作处理器 `DisassembleOperationHandler` 完成，用户同样也可以在注解中使用 `handler` 或 `handlerName` 指定要使用的处理器。比如：

~~~java
public class Department {
    private Integer id;
    @Disassemble(
        type = Employee.class,
        handler = ReflectDisassembleOperationHandler.class // 指定操作处理器
    )
    private List<Employee> employees;
}
~~~

在配置解析过程中，会根据指定的类型后置 beanName 获取对应的操作处理器。
