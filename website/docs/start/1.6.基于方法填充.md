## 1.6.1.基本使用

在 2.2 及以上版本，你可以通过类似 `@AssembleEnum` 的方式，快速的基于类中的实例或者静态方法声明一个装配操作：

~~~java
@RequiredArgsConstructor
@AllArgsConstructor
@Data
private static class Foo {
    @AssembleMethod(
        targetType = Target.class,  // 指定从 Target 类中寻找方法
        method = @ContainerMethod( 
            bindMethod = "getAll",  // 要绑定的方法名称
            resultType = Foo.class, resultKey = "id" // 方法的返回值类型与对应的主键
        )
        props = @Mapping("name") // 映射两者的 name 属性
    )
    private final Integer id;
    private String name;
}

private static class Target {
    
    // 可以作为数据源的方法
    public static Collection<Foo> getAll(Collection<Integer> ids) {
        return ids.stream()
            .map(id -> new Foo(id, "name" + id))
            .collect(Collectors.toList());
    }
}
~~~

在上述代码中，我们声明了这样一个操作：

+ 从 `Target` 类中寻找 `getAll` 方法，将其作为数据源；
+ 根据 `genderCode` 集合从 `getAll` 方法中获取 `Foo` 对象，并按 `id` 分组； 
+ 根据待填充对象的 `id` 找到对应从方法中得到的 `Foo`；
+ 将找到的 `Foo` 对象中的 `id` 映射到待填充的 `Foo` 中的 `name` 属性；

:::info

实际使用时，方法也可以是无参方法。

:::

**通过类全限定名指定类型**

与 `@AssembleEnum` 一样，若不便直接在注解上引用类型，也可以通过类全限定名指定类型：

~~~java
@AssembleMethod(
    target = "com.example.bean.Target",  // 指定从 Target 类中寻找方法
    method = @ContainerMethod( 
        bindMethod = "getAll",  // 要绑定的方法名称
        resultType = Foo.class, resultKey = "id" // 方法的返回值类型与对应的主键
    )
    props = @Mapping("name") // 映射两者的 name 属性
)
private final Integer id;
~~~

**通过方法参数精准查找**

在默认情况下，若存在重载方法，那么 cranej4 总是以首个被找到的方法为准。你也可以指定方法的参数类型，以便做到精准绑定：

~~~java
@AssembleMethod(
    target = "com.example.bean.Target",
    method = @ContainerMethod( 
        bindMethod = "getAll",
        resultType = Foo.class, resultKey = "id"，
        bindMethodParamTypes = Collection.class
    )
    props = @Mapping("name")
)
private final Integer id;
~~~

:::info

除此之外，你按下文的方式，直接在方法上添加 `@ContainerMethod` 注解将其作为数据源，然后按传统方式使用 `@Assemble` 注解配置填充操作，实际上我们也更推荐这种方式。

:::

## 1.6.2.将 Bean 作为方法源

若要作为源的方法不是静态方法，那么 cranej4 将会尝试通过反射创建一个对象实例用于完成方法调用。

不过，若在 Spring 环境，你也可以通过在 `target` 属性上指定 `beanName`，将 Spring 容器中的 bean 用于方法调用：

~~~java
@AssembleMethod(
    target = "fooService", // 从 Spring 容器中寻找名为 fooService 的 bean
    method = @ContainerMethod( 
        bindMethod = "getByIds",
        resultType = Foo.class, resultKey = "id"
    )
    props = @Mapping("name")
)
private final Integer id;
~~~

当然，此时你依然可以指定 `targetType` 属性，那么查找 `bean` 的时候，将会通过 `beanName` + `beanType` 一并进行查找。

## 1.6.3.作为独立数据源

与 `@AssembleEnum` 一样，你可以通过在方法上添加 `@ContainerMethod` 将实例方法声明的独立的数据源容器，并在将其注册到全局配置对象后，基于其使用 `@Assemble` 按传统方式声明填充配置：

**声明方法数据源**

在 spring 环境中，你只需要在 bean 中方法添加 `@ContainerMethod` 注解，即可将其声明的数据源为容器：

~~~java
@Component
public class FooService {
    @ContainerMethod(namespace = "foo", resultType = Foo.class, resultKey = "id")
    public List<Foo> getByIds(Collection<Integer> ids) {
        // return foo list.
    }
}
~~~

在对 `FooService` 进行后处理的过程中，会自动将其注册到全局配置对象。

**声明装配操作**

然后，我们将其作为一个正常的数据源使用：

~~~java
@RequiredArgsConstructor // 使用 lombk 生成构造器
public class Foo {
    @Assemble(container = "foo", props = @Mapping("name"))
    private final Integer id;
    private String name;
}
~~~

:::info

更多关于 `@ContainerMethod` 更多的配置和用法，请参见后文 “数据源容器” 一章中的 “方法” 一节。

:::