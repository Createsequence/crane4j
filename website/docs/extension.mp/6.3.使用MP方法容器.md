### 6.3.1.使用@AssembleMp

用户可以使用 `@AssembleMp` 注解，配置以 `BaseMapper` 接口的查询方法作为数据源的装配操作：

~~~java
public class Foo {
    @AssembleMp(
        mapper = "fooMapper", // 指定调哪一个 Mapper，名称为其在 Spring 中的 beanName
        props = @Mapping(src = "name", ref = "name")
    )
    private Integer id;
    private String name;
}
~~~

当执行装配时，数据源等同于基于 `id` 批量查询出来的 `Bean` 对象，SQL 同 `select * from foo where id in ?`。 

> `@AssembleMp` 注解由 `MpAnnotationOperationsResolver` 解析器完成。

### 6.3.2.使用@Assemble

处了直接使用 `@AssembleMp` 注解外，也可以使用默认的 `@Assemble` 注解，不过相对普通的方法容器，它使用起来会有一点区别：

- 需要指定容器提供者为 `MpMethodContainerProvider`；
- 容器的需要通过表达式获得；

比如：

~~~java
public class Foo {
    @Assemble(
		container = "container('fooMapper')", // 指定调哪一个 Mapper，名称为其在 Spring 中的 beanName
		containerProvider = "mpMethodContainerProvider", // 固定为提供者在 Spring 上下文中的 beanName
         props = @Mapping(src = "name", ref = "name")
    )
    private Integer id;
    private String name;
}
~~~

或参照[组合注解](./../advance/5.2.组合注解.md)封装组合注解简化配置，默认已经提供了一个组合注解 `@AssembleByMp`。

~~~java
public class Foo {
    @AssembleByMp(container = "container('fooMapper')", props = @Mapping(src = "name", ref = "name"))
    private Integer id;
    private String name;
}
~~~

当执行装配时，数据源等同于基于 `id` 批量查询出来的 `Bean` 对象，SQL 同 `select * from foo where id in ?`。 

:::tip

其中，`container()` 是在表达式中固定的函数名称，表示从提供者中获取容器；

:::
