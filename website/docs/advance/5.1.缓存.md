## 概述

<img src="https://img.xiajibagao.top/image-20230225011748030.png" alt="image-20230225011748030"  />

在 `crane4j` 中，具体每个缓存对应一个缓存对象 `Cache`，数据源容器通过持有缓存对象获得缓存读写能力，所有的 `Cache` 都会被一个全局的缓存管理器 `CacheManager` 管理。

## 5.1.1.缓存管理器

参照 `spring-cache` ，在 `crane4j` 中，缓存功能由缓存管理器 `CacheManager` 与具体的缓存对象 `Cache` 共同完成，其中，缓存管理器负责管理缓存对象的创建与销毁，而缓存对象提供具体的读写功能。

默认提供了两种实现：

- `ConcurrentMapCacheManager`：提供基于 `WeakConcurrentMap` 的缓存对象，无法设置过期策略，只能等 `jvm` 自动回收缓存，它是默认的缓存管理器；
- `GuavaCacheManager`：提供基于 `Guava` 的 `Cache` 的实现缓存，支持在创建时指定 `CacheBuilder` 以便定义过期时间以及并发等级等配置；

**替换缓存实现方式**

通过替换 spring 上下文中的缓存管理器可以切换不同的全局缓存。比如要将默认的缓存更换为 `guava-cache`，可以在配置类中直接声明一个 `GuavaCacheManager` 替换默认的管理器：

~~~java
@Bean
public class GuavaCacheManager guavaCacheManager() {
    new GuavaCacheManager(() -> CacheBuilder.newBuilder()
            .maximumSize(100)
            .concurrencyLevel(Runtime.getRuntime().availableProcessors())
            .build());
}
~~~

**创建和销毁缓存**

我们可以通过 `CacheManager` 去创建并获取一个缓存对象 `Cache`：

~~~java
// 获取名称为 foo 的缓存对象
Cache<String> cache = cacheManager.getCache("foo");
// 通过缓存对象操作缓存
cache.get("cacheKey");
cache.put("cacheKey", "cacheValue");
~~~

 也可以通过 `CacheManager` 来销毁缓存：

~~~java
// 销毁名称为 foo 的缓存对象
cacheManager.removeCache("foo");
~~~

缓存管理器和缓存对象一般并不直接使用，而是配合缓存容器等机制间接使用。

:::warning

当销毁缓存对象时，已经获得的缓存对象依然可以使用（但是数据可能已被清空），通过 `Cache.isExpired()` 可以知道缓存是否已经过期。

:::

## 5.1.2.数据源缓存容器缓存

容器缓存基于缓存容器包装类 `CacheableContainer` 实现，它可以包装任何容器使其获得缓存功能：

~~~java
// 创建一个原始容器
Container<String> original = LambdaContainer.forLambda("original", keys -> {
    return Collections.emptyMap();
});
// 基于原始容器与缓存对象，构建带有缓存功能的容器
CacheManager cacheManager = StringUtils.getBean(CacheManager.class);
CacheableContainer<String> container = new CacheableContainer<>(original, cacheManager, "cacheName");
~~~

其中，缓存的粒度是 key 级别，即第一次查询 a, b，则会对 a, b 进行缓存，第二次查询 a, b, c，那么就只会查询 c 然后再增量添加缓存，而 a, b 直接从缓存中获取。

## 5.1.3.配置缓存容器

你可以通过三种方式将一个普通容器配置为缓存容器：

**手动替换**

获取全局配置类 `Crane4jGlobalConfiguration`，并使用 `replaceContainer` 方法将原始的容器替换为包装后的缓存容器：

~~~java
Crane4jGlobalConfiguration configuration = StringUtils.getBean(Crane4jGlobalConfiguration.class);
CacheManager cacheManager = StringUtils.getBean(CacheManager.class);
// 将原始容器包装并替换为缓存容器
configuration.compute("namespace", container -> {
    return new CacheableContainer<>((Container<Object>)container, cacheManager, "cacheName");
})
~~~

**添加注解**

如果是通过 `@ContainerMethod` 声明的方法容器，可以注解在方法上添加 `@ContainerCache` 注解：

~~~java
@ContainerCache // 声明该方法容器为可缓存容器
@ContainerMethod(resultType = Foo.class)
public List<Foo> oneToManyMethod(List<String> args) {
    return args.stream().map(key -> new Foo(key, key)).collect(Collectors.toList());
}
~~~

或者也可以使用 `@CacheContainerMethod` 组合注解:

~~~java
@CacheContainerMethod(resultType = Foo.class)
public List<Foo> oneToManyMethod(List<String> args) {
    return args.stream().map(key -> new Foo(key, key)).collect(Collectors.toList());
}
~~~

方法容器创建后，将会自动包装为缓存容器。

**配置文件**

你也可以直接在配置文件中声明要将哪些容器包装为缓存容器：

~~~yml
crane4j:
 cache-containers:
  cache-name: container-namespace
~~~

比如上述配置文件中，声明将命名空间为 `container-namespace` 的容器包装为缓存容器，使用的缓存名称为 `cache-name`。