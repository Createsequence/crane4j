## 3.1.1.在属性上声明

通常情况下，可以使用 `@Assemble` 在某个键字段上声明装配操作，如下所示：

```java
public class Student {
    @Assemble(container = "student", props = @Mapping(src = "studentName", ref = "name"))
    private Integer id;
    private String name;
}
```

上述配置表示以下操作：

1. 使用 `id` 字段的值；
2. 从命名空间为 `student` 的数据源容器中获取数据源对象；
3. 获取与 `id` 字段值对应的数据，将数据源对象中的 `studentName` 字段值映射到 `name` 字段上；

如果 `src` 和 `ref` 指向的字段相同，也可以直接使用 `value` 属性同时指定，例如：

```java
public class Student {
    @Assemble(container = "student", props = @Mapping("name")) // source.name -> target.name
    private Integer id;
    private String name;
}
```

## 3.1.2.在类上声明

在无法直接修改父类的情况下，可以在类上添加注解来声明装配操作，例如：

```java
// 直接声明
@Assemble(
    key = "id", // 手动指定绑定到 id 字段上
    container = "student", 
    props = @Mapping(src = "studentName", ref = "name")
)
public class Student {
    private Integer id;
    private String name;
}
```

与在属性上直接声明不同，需要通过 `key` 属性绑定相应的键字段。

:::tip

- 在父类或父类属性中声明的操作也会被子类继承；
- `key` 属性默认支持使用 `xx.xx.xx` 格式的链式操作符访问嵌套对象的属性；

:::

## 3.1.3.声明多个操作

有时候，我们需要在同一个键上声明多次装配操作，这是允许的，例如：

```java
public class UserVO {
    @Assemble(container = "user", props = @Mapping(src = "role", ref = "role"), groups = "admin")
    @Assemble(container = "user", props = @Mapping(src = "name", ref = "name"), groups = {"base", "admin"})
    private Integer id;
    private String name;
    private String role;
}
```

:::tip

无需担心多次查询数据源的问题，默认的操作执行器 `DisorderedBeanOperationExecutor` 会将相同容器的操作合并执行，以减少数据源容器的调用次数。

:::

## 3.1.4.动态的表达式

在 `@Assemble` 注解的 `container` 属性中，可以使用与 `@Value` 相似的方式引用配置文件的属性，例如：

```java
public class Foo {
    @Assemble(container = "${custom.namespace}")
    private String name;
    private String alias;
}
```

也可以使用 SpEL 表达式，例如：

```java
public class Foo {
    @Assemble(container = "${custom.namespace} + '$$defaultProvider'")
    private String name;
    private String alias;
}
```

:::tip

此功能仅在Spring环境中支持。

:::

## 3.1.5.key类型强制转换

在一些情况下，你的数据源容器接受的 key 类型与你实际可以提供的 key 类型并不相同，因此有可能由于执行时无法根据 key 找到对应的数据源对象，从而导致填充失效。

在 2.2 及以上版本，你可以在注解中通过 `keyType`  强制将 key 的类型转为指定类型，从而保证它与数据源接受的参数类型一致。比如：

~~~java
// 容器对应的key类型为Integer集合
Containers.<Integer>forLambda("foo", ids -> ids.stream().collector(Collectors.toMap(Function::identify, Function::identify)));

// 带填充对象的key类型为String
public class Foo {
    @Assemble(
        container = "foo", props = @Mapping(src = "a", ref = "b"),
        keyType = Integer.class // 指定 key 类型强制转为 Integer
    )
    private String id;
    private String b;
}
~~~

在上述代码中，我们的数据源容器 `foo` 仅接受 `Integer` 类型的参数，而 `foo.id` 的类型却是 `String`，因此通过 `keyType` 指定其需要在执行时将 key 转为 `Integer`。

:::tip

从 2.2 版本开始，`cranej4` 提供了用于在序列化过程中进行填充的 `jackson` 插件，`jackson` 插件默认从 JsonNode 中拿到的所有 key 值都为 `String` 类型，因此当使用此插件时，若你的数据源容器接受的参数类型不是 `String`，则必须手动显式的在注解配置中指定 key 的类型。

:::

## 3.1.6. 属性映射策略

在默认情况下，当我们指定要将数据源对象的 a 属性映射到目标对象的 b 属性时，仅当 a 的属性值不为 `null` 才会对 b 属性进行赋值。

在 `2.1.0` 及以上版本， 该行为可以通过在装配操作中配置不同的属性映射策略改变，比如，如果我们希望仅当目标对象的 b 属性值为 `null` 时，才允许将数据源对象的 a 属性值映射过来：

~~~java
public class Foo {
    @Assemble(
        container = "foo", props = @Mapping(src = "a", ref = "b"),
        propertyMappingStrategy = "ReferenceMappingStrategy" // 指定属性映射策略
    )
    private String id;
    private String b;
}
~~~

默认提供了三种策略：

+ 覆写 `OverwriteMappingStrategy`：不论 `src` 对应的属性值是不是 `null` ，都强制覆写 `ref` 对应的目标属性；

+ 非空值时覆写 `OverwriteNotNullMappingStrategy`：仅当 `src` 对应的属性值不为 `null` 时，强制覆写 `ref` 对应的目标属性。

    当不指定策略时，将默认使用它作为实际的映射策略；

+ 空值时引用 `ReferenceMappingStrategy`：仅当 `ref` 对应的目标属性为 `null` 时，才获取 `src` 的属性值；

**自定义策略**

你可以通过实现 `PropertyMappingStrategy` 接口创建自定义策略，然后在将其注册到任何基于 `AbstractAssembleAnnotationHandler` 实现的 `OperationAnnotationHandler` 注解处理器中使用。

在 spring 环境中，你只需要将自定义容器交由 spring 容器管理即可，项目启动后 cranej4 会自动将它们注册到对应的注解处理器中。