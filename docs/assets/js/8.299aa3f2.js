(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{274:function(v,_,s){v.exports=s.p+"assets/img/image-20230220191856595.fbd0659c.png"},291:function(v,_,s){"use strict";s.r(_);var e=s(14),a=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"_1-4-1-执行流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-1-执行流程"}},[v._v("#")]),v._v(" 1.4.1.执行流程")]),v._v(" "),_("p",[_("img",{attrs:{src:s(274),alt:"image-20230220191856595"}})]),v._v(" "),_("p",[_("code",[v._v("crane4j")]),v._v(" 的整体执行流程并不复杂，可大致分为两阶段：")]),v._v(" "),_("ul",[_("li",[v._v("配置解析阶段：根据 "),_("code",[v._v("AnnotatedElement")]),v._v(" （一般是类或者方法）解析获得对应的操作配置对象 "),_("code",[v._v("BeanOperation")]),v._v("，通过该配置对象我们可以知道一个对象中有多少个字段需要处理，要怎么处理，在 "),_("code",[v._v("BeanOperation")]),v._v(" 里面，一个 "),_("code",[v._v("key")]),v._v(" 字段对应的一个操作会被转为一个 "),_("code",[v._v("Operation")]),v._v(" 对象；")]),v._v(" "),_("li",[v._v("操作执行阶段：输入要处理的对象，与该对象类型对应操作配置，然后交由操作执行器 "),_("code",[v._v("BeanOperationExecutor")]),v._v(" 生成待完成的任务 "),_("code",[v._v("Execution")]),v._v("，并最终分发给操作执行器 "),_("code",[v._v("OperationHandler")]),v._v("，"),_("code",[v._v("OperationHandler")]),v._v(" 会根据配置从数据源获得对象，并完成具体的字段映射；")])]),v._v(" "),_("p",[v._v("比如上图，即描述了 "),_("code",[v._v("Foo")]),v._v(" 对象是如何通过 "),_("code",[v._v("id")]),v._v(" 获得数据源，并将数据源中的 "),_("code",[v._v("userName")]),v._v(" 字段值映射到 "),_("code",[v._v("Foo")]),v._v(" 的 "),_("code",[v._v("name")]),v._v(" 字段上的。")]),v._v(" "),_("h2",{attrs:{id:"_1-4-2-操作配置-配置解析器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-2-操作配置-配置解析器"}},[v._v("#")]),v._v(" 1.4.2.操作配置 & 配置解析器")]),v._v(" "),_("p",[v._v("在 "),_("code",[v._v("crane4j")]),v._v(" 中，操作是任务的最小单位，它分为两类：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("装配操作")]),v._v(" ：对应接口为 "),_("code",[v._v("AssembleOperation")]),v._v("，即“把xx塞到xx”这样的行为，“根据 A 的 key 值拿到 B，再把 B 的属性映射到 A” 这句话描述的就是一次装配操作；")]),v._v(" "),_("li",[_("strong",[v._v("拆卸操作")]),v._v("：对应接口为 "),_("code",[v._v("DisassembleOperation")]),v._v("，即“把xx从xx中拿出来”这样的行为，当存在需要处理的嵌套对象时，我们需要先把嵌套对象取出并展开，则就是一次拆卸操作；")])]),v._v(" "),_("p",[v._v("它们有一个共同的特点，就是需要绑定在某个特定属性上，比如装配操作就需要绑定一个外键的字段，而拆卸操作需要绑定装有嵌套对象的字段，它们都称为 "),_("strong",[v._v("key 字段")]),v._v("。")]),v._v(" "),_("p",[v._v("我们的一个对象——通常也对应一个 "),_("code",[v._v("Class")]),v._v(" ——里面往往会有多个 key 字段，比如我有一个 "),_("code",[v._v("Classroom")]),v._v(" 对象：")]),v._v(" "),_("div",{staticClass:"language-java extra-class"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("public")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("class")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Classroom")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("private")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Integer")]),v._v(" id"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("private")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("String")]),v._v(" name"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("private")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Teacher")]),v._v(" teacher"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("private")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("List")]),_("span",{pre:!0,attrs:{class:"token generics"}},[_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("<")]),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Student")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(">")])]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Student")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("public")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("class")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Student")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("private")]),v._v(" id"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("private")]),v._v(" name"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n")])])]),_("p",[v._v("我们可能只有一个 id，而需要根据 "),_("code",[v._v("id")]),v._v(" 查到并填充它的 "),_("code",[v._v("name")]),v._v("、"),_("code",[v._v("teacher")]),v._v(" 属性，并且还要根据它内部携带的 "),_("code",[v._v("Student")]),v._v(" 的 "),_("code",[v._v("id")]),v._v(" 填充对应的 "),_("code",[v._v("name")]),v._v(" 字段集合，在这种情况下，一个 "),_("code",[v._v("Classroom")]),v._v(" 类将会绑定三个操作：")]),v._v(" "),_("ul",[_("li",[v._v("根据 "),_("code",[v._v("Classroom.id")]),v._v(" 填充 "),_("code",[v._v("Classroom.name")]),v._v(" 的装配操作；")]),v._v(" "),_("li",[v._v("根据 "),_("code",[v._v("Classroom.id")]),v._v(" 填充 "),_("code",[v._v("Classroom.teacher")]),v._v(" 的装配操作；")]),v._v(" "),_("li",[v._v("将 "),_("code",[v._v("Classroom.student")]),v._v(" 展开的拆卸操作；")])]),v._v(" "),_("p",[v._v("为了便于管理，每个 "),_("code",[v._v("Class")]),v._v(" 都会缓存一个操作配置聚合，即"),_("strong",[v._v("类的操作配置")]),v._v(" "),_("code",[v._v("BeanOperations")]),v._v("，里面记录这个类的所有装配操作和拆卸操作，而集中提供读取 "),_("code",[v._v("Class")]),v._v(" 并且生成操作配置的类，就是"),_("strong",[v._v("配置解析器")]),v._v(" "),_("code",[v._v("BeanOperationsParser")]),v._v("，其中每一个配置注解（比如 "),_("code",[v._v("@Assemble")]),v._v("）都会有对应的"),_("strong",[v._v("注解解析器")]),v._v(" "),_("code",[v._v("OperationAnnotationResolver")]),v._v(" 。")]),v._v(" "),_("p",[v._v("而被处理的对象 "),_("code",[v._v("Classroom")]),v._v(" 就是"),_("strong",[v._v("待处理对象")]),v._v("，而从容器中根据 "),_("code",[v._v("id")]),v._v(" 得到的 "),_("code",[v._v("Classroom")]),v._v(" 对象，就是"),_("strong",[v._v("数据源对象")]),v._v("。")]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),_("p",[v._v("将操作注解配置在 "),_("code",[v._v("Class")]),v._v(" 以及 "),_("code",[v._v("Field")]),v._v(" 上是最常见的，不过实际上 "),_("code",[v._v("crane4j")]),v._v(" 支持从任何 "),_("code",[v._v("AnnotatedElement")]),v._v(" 上解析注解并生成配置对象，这意味着如果有必要你也可以把配置配置在方法甚至方法参数上，比如执行操作一章中提到的执行者接口。")])]),v._v(" "),_("h2",{attrs:{id:"_1-4-3-操作处理器-操作执行器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-3-操作处理器-操作执行器"}},[v._v("#")]),v._v(" 1.4.3.操作处理器 & 操作执行器")]),v._v(" "),_("p",[v._v("现在我们通过 "),_("code",[v._v("Class")]),v._v(" 可以得到待执行的装配操作和拆卸操作配置，然而最终还是需要有一个处理器，去真正的根据配置完成对应的属性读写，此即为操作处理器，其中装配操作由"),_("strong",[v._v("装配操作处理器")]),v._v(" "),_("code",[v._v("AssembleOperationHandler")]),v._v(" 完成，而拆卸操作由"),_("strong",[v._v("拆卸操作处理器")]),v._v(" "),_("code",[v._v("DisassembleOperationHandler")]),v._v(" 完成。")]),v._v(" "),_("p",[v._v("不过，因为操作间允许排序，因此有的操作需要先执行，有的操作需要后执行；并且由于拆卸操作的存在，虽然我们要填充的对象都是 A 类型的，但是通过拆卸操作最终可能拆出来一堆其他类型的对象，这些对象也会有拆卸操作，也会有需要排序的装配操作；为了提高效率，数据源相同的操作最好放在一起完成以便减少获取数据源的次数......")]),v._v(" "),_("p",[v._v("总而言之，我们需要有一个组件，可以尽可能高效而清晰的将操作归类分组，并变成一个批量任务，最终再交由对应的操作处理器完成，这个组件就是"),_("strong",[v._v("操作执行器")]),v._v(" "),_("code",[v._v("BeanOperationsExecutor")]),v._v("，而批量任务即为"),_("strong",[v._v("执行对象")]),v._v(" "),_("code",[v._v("AssembleExecution")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"_1-4-4-数据源容器-属性映射"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-4-数据源容器-属性映射"}},[v._v("#")]),v._v(" 1.4.4.数据源容器 & 属性映射")]),v._v(" "),_("p",[v._v("每个装配操作必然具备三个基本要素：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("key 字段")]),v._v("：即用于关联填充数据的外键字段；")]),v._v(" "),_("li",[_("strong",[v._v("数据源容器")]),v._v("：即根据 key 字段值用于获取填充数据的组件；")]),v._v(" "),_("li",[_("strong",[v._v("属性映射")]),v._v("：获取到 key 字段值对应的数据源对象后，要把它的哪些属性值塞到自己的哪些属性值里；")])]),v._v(" "),_("p",[v._v("只要操作处理器支持，数据源容器可以接受，则 key 字段的类型可以是常规的 id 值，或者用分隔符拼接成的 id 字符串，甚至是集合。而属性映射也是同理，只要操作处理器支持，填充的对象和数据源对象的类型是个普通的 JavaBean，还是枚举，甚至是 Map 集合或者数组都行。")]),v._v(" "),_("p",[v._v("数据源容器本身也可以是任何实现了 "),_("code",[v._v("Container")]),v._v(" 接口的东西，它可以是一个简陋的 Map 集合，一段可以调用的方法，甚至是固定的常量，能接受输入 key 值并且返回按 key 值分组的数据的东西都可以作为数据源容器。")]),v._v(" "),_("h2",{attrs:{id:"_1-4-5-设计原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-5-设计原则"}},[v._v("#")]),v._v(" 1.4.5.设计原则")]),v._v(" "),_("p",[_("code",[v._v("crane4j")]),v._v(" 在设计的时候，遵循两个原则：")]),v._v(" "),_("ul",[_("li",[v._v("对于 api，希望能够尽可能的符合直觉，即用户觉得这样做应该会有这样的效果，那么它就应该是这样的效果；")]),v._v(" "),_("li",[v._v("对于代码，则希望每个类尽可能做到单一职责，然后再通过细粒度组件的复用与组合来实现功能；")])]),v._v(" "),_("p",[v._v("实际上某种程度上来说，后者是前者的基础，因为有了灵活的细粒度组件，所以我们才可以通过多种方式去组合出我们所需要的功能。这种编码风格，提升了代码的可读性、可测性和可扩展性，不过作为代价，"),_("code",[v._v("crane4j")]),v._v(" 实现某个功能可能需要比较多的类来完成，这导致在缺少类似 spring 这类的 IOC 容器时使用起来会比较爪麻，以及更多的对象所带来的一些内存占用，不过相对收获来说还是很划算的。")]),v._v(" "),_("p",[v._v("作者希望用户使用默认的配置能够用的舒心，但是若有必要也能通过最小范的调整适配自己的逻辑，")])])}),[],!1,null,null,null);_.default=a.exports}}]);