(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{322:function(e,t,a){"use strict";a.r(t);var v=a(14),_=Object(v.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"faq"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#faq"}},[e._v("#")]),e._v(" FAQ")]),e._v(" "),t("p",[e._v("以下是一些常见问题与对应的解决方案。如果当你遇到问题时，可以先尝试在这里寻找解决方案。")]),e._v(" "),t("h2",{attrs:{id:"填充不生效"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#填充不生效"}},[e._v("#")]),e._v(" 填充不生效？")]),e._v(" "),t("ul",[t("li",[e._v("确认 "),t("code",[e._v("@AssembleXXX")]),e._v(" 注解正确配置了 "),t("code",[e._v("container")]),e._v(" 与 "),t("code",[e._v("prop")]),e._v(" 属性；")]),e._v(" "),t("li",[e._v("确认操作涉及的属性存在，且都有相应的 "),t("code",[e._v("setter")]),e._v(" 和 "),t("code",[e._v("getter")]),e._v(" 方法；")]),e._v(" "),t("li",[e._v("确认目标对象对应的 key 属性值不为空；")]),e._v(" "),t("li",[e._v("确认指定的数据源容器确实有根据 key 值列表返回非空集合；")]),e._v(" "),t("li",[e._v("确认通过 "),t("code",[e._v("BeanOperationParser")]),e._v(" 解析类后，得到的 "),t("code",[e._v("BeanOperations")]),e._v(" 中的 "),t("code",[e._v("AssembleOperation")]),e._v(" 列表中有该 key 属性对应的操作配置；")])]),e._v(" "),t("p",[e._v("当确认上述步骤皆无问题后，你可以尝试在源码中 "),t("code",[e._v("cn.crane4j.core.executor.handler.AbstractAssembleOperationHandler")]),e._v(" 类的 "),t("code",[e._v("doProcess")]),e._v(" 方法中添加断点：")]),e._v(" "),t("ul",[t("li",[e._v("如果未进入断点，则说明该操作配置未能生效，请重新确认上述原因；")]),e._v(" "),t("li",[e._v("进入 "),t("code",[e._v("collectToEntities")]),e._v("：在这一步，确认你填充的对象是否都已经被收集到，且 key 值被正确的获取；")]),e._v(" "),t("li",[e._v("进入 "),t("code",[e._v("getSourcesFromContainer")]),e._v("：在这一步，确认通过上述 key 值能够正确的从数据源获取到数据；")]),e._v(" "),t("li",[e._v("进入 "),t("code",[e._v("getTheAssociatedSource")]),e._v("：在这一步，确认待填充的对象可以通过 key 值获得相应的数据源对象；")]),e._v(" "),t("li",[e._v("进入 "),t("code",[e._v("completeMapping")]),e._v("：在这一步，确认 crane4j 是否按你的配置正确的将数据源对象的属性值映射到待填充的对象上；")])]),e._v(" "),t("p",[e._v("如果仍然无法解决，可以在 issues 中或者相关交流群中反馈。")]),e._v(" "),t("h2",{attrs:{id:"如何实现嵌套填充"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何实现嵌套填充"}},[e._v("#")]),e._v(" 如何实现嵌套填充？")]),e._v(" "),t("p",[e._v("在需要嵌套填充的属性上添加 "),t("code",[e._v("@Disassemble")]),e._v(" 注解即可，具体参见 "),t("RouterLink",{attrs:{to:"/basic/declare_disassemble_operation.html"}},[e._v("填充嵌套对象")]),e._v("。")],1),e._v(" "),t("h2",{attrs:{id:"如何实现级联填充"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何实现级联填充"}},[e._v("#")]),e._v(" 如何实现级联填充？")]),e._v(" "),t("ul",[t("li",[e._v("在需要按顺序执行的属性上添加 "),t("code",[e._v("@Order")]),e._v(" 注解（Spring 环境），或直接在 "),t("code",[e._v("@AssembleXXX")]),e._v(" 注解的 "),t("code",[e._v("sort")]),e._v(" 属性指定排序值，越小越先执行；")]),e._v(" "),t("li",[e._v("在指定操作顺序的前提下，使用有序的装配执行器 "),t("code",[e._v("OrderedBeanOperationExecutor")]),e._v(" 完成对目标的填充操作；")])]),e._v(" "),t("p",[e._v("具体参见 "),t("RouterLink",{attrs:{to:"/basic/operation_sort.html"}},[e._v("顺序填充")]),e._v("。")],1),e._v(" "),t("h2",{attrs:{id:"如何处理一对多的情况"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何处理一对多的情况"}},[e._v("#")]),e._v(" 如何处理一对多的情况？")]),e._v(" "),t("p",[e._v("通过 "),t("code",[e._v("@AssembleXXX")]),e._v(" 注解中的 "),t("code",[e._v("handler")]),e._v(" 或 "),t("code",[e._v("handlerType")]),e._v(" 属性指定装配处理器为一对多装配处理器 "),t("code",[e._v("OneToManyAssembleOperationHandler")]),e._v(" 类型或名称（在 Spring 中即为 bean 名称）即可。")]),e._v(" "),t("p",[e._v("具体参见 "),t("RouterLink",{attrs:{to:"/basic/assemble_operation_handler.html"}},[e._v("一对多&多对多")]),e._v(" 中一对多装配一节。")],1),e._v(" "),t("h2",{attrs:{id:"键字段可以是按分隔符拼接的字符串吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#键字段可以是按分隔符拼接的字符串吗"}},[e._v("#")]),e._v(" 键字段可以是按分隔符拼接的字符串吗？")]),e._v(" "),t("p",[e._v("通过 "),t("code",[e._v("@AssembleXXX")]),e._v(" 注解中的 "),t("code",[e._v("handler")]),e._v(" 或 "),t("code",[e._v("handlerType")]),e._v(" 属性指定装配处理器为一对多装配处理器 "),t("code",[e._v("ManyToManyAssembleOperationHandler")]),e._v(" 的类型或名称（在 Spring 中即为 bean 名称）即可。")]),e._v(" "),t("p",[e._v("具体参见 "),t("RouterLink",{attrs:{to:"/basic/assemble_operation_handler.html"}},[e._v("一对多&多对多")]),e._v(" 中多对多装配一节。")],1),e._v(" "),t("h2",{attrs:{id:"键字段可以是集合或者数组吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#键字段可以是集合或者数组吗"}},[e._v("#")]),e._v(" 键字段可以是集合或者数组吗？")]),e._v(" "),t("p",[e._v("同上，通过 "),t("code",[e._v("@AssembleXXX")]),e._v(" 注解中的 "),t("code",[e._v("handler")]),e._v(" 或 "),t("code",[e._v("handlerType")]),e._v(" 属性指定装配处理器为一对多装配处理器 "),t("code",[e._v("ManyToManyAssembleOperationHandler")]),e._v(" 的类型或名称（在 Spring 中即为 bean 名称）即可。")]),e._v(" "),t("p",[e._v("具体参见 "),t("RouterLink",{attrs:{to:"/basic/assemble_operation_handler.html"}},[e._v("一对多&多对多")]),e._v(" 中多对多装配一节。")],1),e._v(" "),t("h2",{attrs:{id:"为什么使用异步执行器的时候报错"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用异步执行器的时候报错"}},[e._v("#")]),e._v(" 为什么使用异步执行器的时候报错？")]),e._v(" "),t("p",[e._v("默认情况下，并没有注册异步操作执行器 "),t("code",[e._v("AsyncBeanOperationExecutor")]),e._v("，用户需要自行创建后再将其注册到全局配置中。")]),e._v(" "),t("p",[e._v("具体参见 "),t("RouterLink",{attrs:{to:"/user_guide/basic_concept.html"}},[e._v("基本概念")]),e._v(" 中异步执行器一节。")],1),e._v(" "),t("h2",{attrs:{id:"怎么刷新容器的数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#怎么刷新容器的数据"}},[e._v("#")]),e._v(" 怎么刷新容器的数据 ？")]),e._v(" "),t("ul",[t("li",[e._v("如果容器是 "),t("code",[e._v("ConstantContainer")]),e._v(" ，直接通过 "),t("code",[e._v("get")]),e._v(" 方法获取缓存的 "),t("code",[e._v("Map")]),e._v(" 集合后直接修改即可；")]),e._v(" "),t("li",[e._v("获取 "),t("code",[e._v("Crane4jGlobalConfiguration")]),e._v(" 或 "),t("code",[e._v("ContainerManager")]),e._v(" 后，通过 "),t("code",[e._v("registerContainer")]),e._v(" 使用命名空间相同的容器对旧容器进行覆盖；")])]),e._v(" "),t("h2",{attrs:{id:"怎么忽略掉某些字段不进行填充"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#怎么忽略掉某些字段不进行填充"}},[e._v("#")]),e._v(" 怎么忽略掉某些字段不进行填充？")]),e._v(" "),t("ul",[t("li",[e._v("使用 "),t("code",[e._v("@AssembleXXX")]),e._v(" 注解的 "),t("code",[e._v("groups")]),e._v(" 属性对指定操作进行分组；")]),e._v(" "),t("li",[e._v("在配置了分组的前提下，在使用 "),t("code",[e._v("OperateTemplate")]),e._v(" 手动填充，或通过被 "),t("code",[e._v("@AutoOperate")]),e._v(" 注解的方法进行自动填充时，指定仅执行/仅不执行特定分组的操作；")])]),e._v(" "),t("p",[e._v("具体参见 "),t("RouterLink",{attrs:{to:"/basic/operation_group.html"}},[e._v("分组填充")]),e._v(" 一节。")],1),e._v(" "),t("h2",{attrs:{id:"为什么-containermethod-注解不生效"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么-containermethod-注解不生效"}},[e._v("#")]),e._v(" 为什么 "),t("code",[e._v("@ContainerMethod")]),e._v(" 注解不生效？")]),e._v(" "),t("p",[e._v("如果是非 Spring 环境，则需要手动的通过 "),t("code",[e._v("ContainerMethodAnnotationProcessor")]),e._v(" 扫描指定类并向全局配置注册扫描获取的方法容器。")]),e._v(" "),t("p",[e._v("如果是 Spring 环境，请确保：")]),e._v(" "),t("ul",[t("li",[e._v("容器中存在 "),t("code",[e._v("BeanMethodContainerRegistrar")]),e._v(" 后处理器；")]),e._v(" "),t("li",[e._v("被注解的方法所在类被 Spring 扫描，且容器中存在对应的 bean；")]),e._v(" "),t("li",[e._v("被注解的方法所在类在 "),t("code",[e._v("BeanMethodContainerRegistrar")]),e._v(" 后处理器初始化后才加载；")])]),e._v(" "),t("h2",{attrs:{id:"为什么-autooperate-注解不生效"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么-autooperate-注解不生效"}},[e._v("#")]),e._v(" 为什么 "),t("code",[e._v("@AutoOperate")]),e._v(" 注解不生效？")]),e._v(" "),t("p",[e._v("如果是非 Spring 环境，则需要手动的通过 "),t("code",[e._v("MethodArgumentAutoOperateSupport")]),e._v(" 和 "),t("code",[e._v("MethodResultAutoOperateSupport")]),e._v(" 拦截方法调用。")]),e._v(" "),t("p",[e._v("如果是 Spring 环境，请确保：")]),e._v(" "),t("ul",[t("li",[e._v("开启了 "),t("code",[e._v("SpringAOP")]),e._v(" 功能；")]),e._v(" "),t("li",[e._v("容器中存在 "),t("code",[e._v("MethodResultAutoOperateAdvisor")]),e._v(" 或 "),t("code",[e._v("MethodArgumentAutoOperateAdvisor")]),e._v(" 通知器；")]),e._v(" "),t("li",[e._v("被注解的方法所在类被 Spring 扫描、容器中存在对应的 bean 且被 Spring 代理；")])]),e._v(" "),t("h2",{attrs:{id:"为什么引了-guava-和-hutool"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么引了-guava-和-hutool"}},[e._v("#")]),e._v(" 为什么引了 guava 和 hutool ？")]),e._v(" "),t("p",[e._v("不想要重复造轮子，有些组件直接使用成熟的开源库比自己再写一套更可靠。")]),e._v(" "),t("p",[e._v("此外，"),t("code",[e._v("crane4j")]),e._v(" 仅在有限的地方使用了这些工具类库：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("guava")]),e._v(" ：使用了缓存组件 "),t("code",[e._v("Cache")]),e._v(" 与用于构造 "),t("code",[e._v("WeakConcurrentMap")]),e._v(" 的  "),t("code",[e._v("MapMaker")]),e._v("；")]),e._v(" "),t("li",[t("code",[e._v("hutool")]),e._v("：使用了类型转换取组件 "),t("code",[e._v("Convert")]),e._v("，如果没用到 "),t("code",[e._v("HutoolConverterManager")]),e._v(" 可以在依赖中排除；")])]),e._v(" "),t("h2",{attrs:{id:"支持-jdk9-springboot3-吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#支持-jdk9-springboot3-吗"}},[e._v("#")]),e._v(" 支持 jdk9+ / springboot3 吗？")]),e._v(" "),t("p",[e._v("在 "),t("code",[e._v("jdk11")]),e._v(" 与 "),t("code",[e._v("jdk17")]),e._v(" 和相应版本 SpringBoot 中测试后可以正常运行。")]),e._v(" "),t("h2",{attrs:{id:"容器可以做一些自定义的初始化-销毁操作吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#容器可以做一些自定义的初始化-销毁操作吗"}},[e._v("#")]),e._v(" 容器可以做一些自定义的初始化/销毁操作吗？")]),e._v(" "),t("p",[e._v("实现 "),t("code",[e._v("Container.Lifecycle")]),e._v(" 接口即可，具体参见 "),t("RouterLink",{attrs:{to:"/advanced/container_lifecycle.html"}},[e._v("容器的生命周期")]),e._v("。")],1),e._v(" "),t("h2",{attrs:{id:"可以支持同时根据多个-key-字段填充数据吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可以支持同时根据多个-key-字段填充数据吗"}},[e._v("#")]),e._v(" 可以支持同时根据多个 key 字段填充数据吗？")]),e._v(" "),t("p",[e._v("可以，不过实现方式有点特殊，具体参照 "),t("RouterLink",{attrs:{to:"/basic/container/object_container.html"}},[e._v("对象容器")]),e._v("。")],1),e._v(" "),t("h2",{attrs:{id:"启动应用报错-no-servletcontext-set"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#启动应用报错-no-servletcontext-set"}},[e._v("#")]),e._v(" 启动应用报错 “No ServletContext set”")]),e._v(" "),t("p",[e._v("在 2.4.0 及更早的版本中，当你在 web 环境中通过 "),t("code",[e._v("@EnableCrane4j")]),e._v(" 注解引入框架后，启动项目有可能会出现 “No ServletContext set” 问题，关于该问题的解决方案参见："),t("a",{attrs:{href:"https://github.com/opengoofy/crane4j/issues/126",target:"_blank",rel:"noopener noreferrer"}},[e._v("在启动类添加 "),t("code",[e._v("@EnableCrane4j")]),e._v(" 注解后，启动应用报错 “No ServletContext set”"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("p",[e._v("简单的来说分为三种：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("升级 crane4j 到 2.4.0 或更高版本。")])]),e._v(" "),t("li",[t("p",[e._v("在自己的项目中定义一个配置类，去继承 "),t("code",[e._v("Crane4jAutoConfiguration")]),e._v("：")]),e._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/**\n * 在项目里面另外建一个配置类继承 Crane4jAutoConfiguration\n * \n * @author huangchengxing\n */")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[e._v("@Configuration")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("class")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Crane4jConfig")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("extends")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Crane4jAutoConfiguration")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])])]),e._v(" "),t("li",[t("p",[e._v("在自己的项目中的 "),t("code",[e._v("META-INF")]),e._v(" 文件夹下通过 SPI 文件引入 crane4j 配置类：")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("在 springboot 2.7 及以上版本，你需要在 "),t("code",[e._v("spirng")]),e._v(" 文件夹下提供一个 "),t("code",[e._v("org.springframework.boot.autoconfigure.AutoConfiguration.imports")]),e._v(" 文件，里面内容如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("cn.crane4j.spring.boot.config.Crane4jAutoConfiguration\ncn.crane4j.spring.boot.config.Crane4jJacksonConfiguration\ncn.crane4j.spring.boot.config.Crane4jMybatisPlusAutoConfiguration\n")])])])]),e._v(" "),t("li",[t("p",[e._v("在 springboot 2.7 以下版本，你需要提供一个 "),t("code",[e._v("spring.factories")]),e._v(" 文件，里面内容如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\n  cn.crane4j.spring.boot.config.Crane4jAutoConfiguration,\\\n  cn.crane4j.spring.boot.config.Crane4jJacksonConfiguration,\\\n  cn.crane4j.spring.boot.config.Crane4jMybatisPlusAutoConfiguration\n")])])])])])])]),e._v(" "),t("h2",{attrs:{id:"可以多线程填充吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可以多线程填充吗"}},[e._v("#")]),e._v(" 可以多线程填充吗？")]),e._v(" "),t("p",[e._v("你可以通过在手动或自动装配时指定使用异步执行器来实现多线程填充的效果，具体参见：")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"./basic_concept"}},[e._v("基本概念-操作执行器")]),e._v("；")]),e._v(" "),t("li",[t("a",{attrs:{href:"./basic/trigger_operation"}},[e._v("触发填充操作-指定执行器")]),e._v("；")])])])}),[],!1,null,null,null);t.default=_.exports}}]);