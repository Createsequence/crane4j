## 安装

**依赖**

在 Spring 项目中，请引入 `crane4j-spring-extension` 依赖：

~~~xml
<dependency>
    <groupId>cn.crane4j</groupId>
    <artifactId>crane4j-extension-spring</artifactId>
    <version>${last-version}</version>
</dependency>
~~~

并请确保已经引入 `spring-context`、`aspectjweaver` 依赖。

**配置类**

由于没有自动装配支持，需要手动配置相关组件，具体内容参考 `Crane4jAutoConfiguration`，这里给出一份可以直接使用的配置类：

~~~java
@EnableAspectJAutoProxy
@Configuration
public class Crane4jSpringConfigurationExample {

    @Primary
    @Bean
    public Crane4jApplicationContext crane4jApplicationContext(ApplicationContext applicationContext) {
        List<ContainerRegisterAware> awareList = applicationContext
            .getBeanNamesForType(ContainerRegisterAware.class).length > 0 ?
            new ArrayList<>(applicationContext.getBeansOfType(ContainerRegisterAware.class).values()) : new ArrayList<>();
        Crane4jApplicationContext context = new Crane4jApplicationContext(applicationContext);
        awareList.forEach(context::addContainerRegisterAware);
        return context;
    }

    @Bean
    public PropertyOperator propertyOperator() {
        PropertyOperator operator = new ReflectPropertyOperator();
        operator = new MapAccessiblePropertyOperator(operator);
        return new ChainAccessiblePropertyOperator(operator);
    }

    @Bean
    public MergedAnnotationFinder mergedAnnotationFinder() {
        return new MergedAnnotationFinder();
    }

    @Bean
    public SimpleTypeResolver simpleTypeResolver() {
        return new SimpleTypeResolver();
    }

    @Bean
    public SpelExpressionEvaluator spelExpressionEvaluator() {
        return new SpelExpressionEvaluator(new SpelExpressionParser());
    }

    @Bean
    public ConcurrentMapCacheManager concurrentMapCacheManager() {
        return new ConcurrentMapCacheManager(CollectionUtils::newWeakConcurrentMap);
    }

    // ============== execute components ==============

    @Bean
    public BeanFactoryResolver beanFactoryResolver(ApplicationContext applicationContext) {
        return new BeanFactoryResolver(applicationContext);
    }

    @Bean
    public SpringAssembleAnnotationOperationsResolver springAnnotationOperationsResolver(
        AnnotationFinder annotationFinder, Crane4jGlobalConfiguration configuration,
        ExpressionEvaluator evaluator, BeanResolver beanResolver) {
        return new SpringAssembleAnnotationOperationsResolver(annotationFinder, configuration, evaluator, beanResolver);
    }

    @Bean
    public DisassembleAnnotationOperationsResolver disassembleAnnotationOperationsResolver(
        AnnotationFinder annotationFinder, Crane4jGlobalConfiguration configuration) {
        return new DisassembleAnnotationOperationsResolver(annotationFinder, configuration);
    }

    @Primary
    @Bean
    public TypeHierarchyBeanOperationParser typeHierarchyBeanOperationParser(Collection<BeanOperationsResolver> beanOperationsResolver) {
        return new TypeHierarchyBeanOperationParser(beanOperationsResolver);
    }

    @Primary
    @Bean
    public DisorderedBeanOperationExecutor disorderedBeanOperationExecutor() {
        return new DisorderedBeanOperationExecutor();
    }

    @Bean
    public OrderedBeanOperationExecutor orderedBeanOperationExecutor() {
        return new OrderedBeanOperationExecutor(Comparator.comparing(AssembleOperation::getSort));
    }

    @Order
    @Bean
    public DefaultMethodContainerFactory defaultMethodContainerFactory(
        PropertyOperator propertyOperator, AnnotationFinder annotationFinder) {
        return new DefaultMethodContainerFactory(propertyOperator, annotationFinder);
    }

    @Order(Ordered.LOWEST_PRECEDENCE - 1)
    @Bean
    public CacheableMethodContainerFactory cacheableMethodContainerFactory(
        CacheManager cacheManager, PropertyOperator propertyOperator, AnnotationFinder annotationFinder) {
        return new CacheableMethodContainerFactory(propertyOperator, annotationFinder, cacheManager);
    }

    @Primary
    @Bean
    public OneToOneReflexAssembleOperationHandler oneToOneReflexAssembleOperationHandler(PropertyOperator propertyOperator) {
        return new OneToOneReflexAssembleOperationHandler(propertyOperator);
    }

    @Bean
    public ManyToManyReflexAssembleOperationHandler manyToManyReflexAssembleOperationHandler(PropertyOperator propertyOperator) {
        return new ManyToManyReflexAssembleOperationHandler(propertyOperator);
    }

    @Bean
    public OneToManyReflexAssembleOperationHandler oneToManyReflexAssembleOperationHandler(PropertyOperator propertyOperator) {
        return new OneToManyReflexAssembleOperationHandler(propertyOperator);
    }

    @Primary
    @Bean
    public ReflectDisassembleOperationHandler reflectDisassembleOperationHandler(PropertyOperator propertyOperator) {
        return new ReflectDisassembleOperationHandler(propertyOperator);
    }

    // ============== extension components ==============

    @Bean
    public OperateTemplate operateTemplate(
        BeanOperationParser parser, DisorderedBeanOperationExecutor executor, TypeResolver typeResolver) {
        return new OperateTemplate(parser, executor, typeResolver);
    }

    @Bean
    public DefaultParameterNameDiscoverer defaultParameterNameDiscoverer() {
        return new DefaultParameterNameDiscoverer();
    }

    @Bean
    public AutoOperateAnnotatedElementResolver autoOperateAnnotatedElementResolver(Crane4jGlobalConfiguration crane4jGlobalConfiguration) {
        return new AutoOperateAnnotatedElementResolver(crane4jGlobalConfiguration);
    }

    @Bean
    public ResolvableExpressionEvaluator resolvableExpressionEvaluator(
        ExpressionEvaluator expressionEvaluator, ParameterNameDiscoverer parameterNameDiscoverer, BeanResolver beanResolver) {
        return new ResolvableExpressionEvaluator(
            parameterNameDiscoverer, expressionEvaluator,
            method -> {
                SpelExpressionContext context = new SpelExpressionContext();
                context.setBeanResolver(beanResolver);
                return context;
            }
        );
    }

    @Bean
    public MethodResultAutoOperateAspect methodResultAutoOperateAspect(
        AutoOperateAnnotatedElementResolver autoOperateAnnotatedElementResolver,
        ResolvableExpressionEvaluator resolvableExpressionEvaluator) {
        return new MethodResultAutoOperateAspect(autoOperateAnnotatedElementResolver, resolvableExpressionEvaluator);
    }

    @Bean
    public MethodArgumentAutoOperateAspect methodArgumentAutoOperateAspect(
        MethodBaseExpressionExecuteDelegate methodBaseExpressionExecuteDelegate,
        AutoOperateAnnotatedElementResolver autoOperateAnnotatedElementResolver,
        ParameterNameDiscoverer parameterNameDiscoverer, AnnotationFinder annotationFinder) {
        return new MethodArgumentAutoOperateAspect(autoOperateAnnotatedElementResolver,
            methodBaseExpressionExecuteDelegate,
            parameterNameDiscoverer, annotationFinder
        );
    }

    @Bean
    public BeanMethodContainerRegistrar beanMethodContainerPostProcessor(
        Collection<MethodContainerFactory> factories, AnnotationFinder annotationFinder, Crane4jGlobalConfiguration configuration) {
        return new BeanMethodContainerRegistrar(factories, annotationFinder, configuration);
    }
}
~~~

确保在项目启动后，上述配置类中配置的组件都已注册到 spring 上下文中。

## 配置数据源容器

在 `crane4j` 中，一个数据源对应一个**数据源容器**，因此在填充前需要先准备好对应的数据源容器。

这里我们简单配置一个命名空间为 `gender` 的数据源容器，它将根据 0 或 1 返回对应的性别名称：

~~~java
// 注册性别信息数据源
Map<Integer> sources = new HashMap<>();
sources.put(0, "女");
sources.put(1, "男");
Container<String> genderContainer= ConstantContainer.forMap("gender", sources);
~~~

接着，我们将其注册到 `crane4j` 的从 spring 上下文获得的全局配置类中：

~~~java
Crane4jApplicationContext context = SpringUtil.getBean(Crane4jApplicationContext.class);
context.registerContainer(genderContainer);
~~~

:::tip

- 注册数据源的步骤我们也可以放到 `ApplicationRunner` 或者被 `@PostConstruct` 注解的回调方法中；
- 处理简单的本地缓存外，`crane4j` 还支持创建其他种类的数据源容器，具体参见后文数据源容器部分内容；

:::

## 配置装配操作

在 `crane4j` 中，对某个对象的填充行为被称为**装配操作**，我们可以通过在类或者类的属性上添加注解来配置一个装配操作。

比如，我们在 `Student` 中声明一个装配操作：

- 基于 **key 字段**  `sex` 完成操作，即根据 `sex` 字段的值去查找关联数据；
- 从命名空间为 `gender` 的**数据源容器**获取关联数据；
- 将获得的关联数据源直接赋值给**引用字段** `sexName`；

~~~java
@RequiredArgsConstructor // 使用 lombok 生成 get 方法和构造器
@Getter
@Setter
public class Student {
    private final String name;

    @Assemble(
        container = "gender", // 指定使用的命名空间为 gender 的数据源容器
        props = @Mapping(ref = "sexName") // 将根据 sex 取得值映射到 sexName 上
    )
    private final Integer sex;
    private String sexName;
}
~~~

上述配置即表示 `根据 sex 从刚配置的 `gender` 数据源容器中查找对应的男/女名称，并映射到 `sexName` 字段上` 这样一个操作。

:::tip

- `@Assemble` 注解用于声明一次填充操作，具体参见后文[装配操作](./../operation/3.1.声明装配操作.md)一节；
- `@Mapping` 用于指明数据源对象上的字段要如何映射到待处理对象的字段上，具体参见后文[字段映射](./../operation/3.4.配置字段映射.md)一节；

:::

## 执行装配操作

在项目启动后，我们可以从 spring 上下文中获取填充工具类 `OperateTemplate` 去填充我们已经配置过的对象：

~~~java
OperateTemplate operateTemplate = SpringUtil.getBean(OperateTemplate.class);
List<Student> students = Arrays.asList(
    new Student("小红", 1), new Student("小明", 2)
);
operateTemplate.execute(students);
~~~

在执行后，`students` 中对象的 `sexName` 将根据 `sex` 字段的值被填充：

~~~java
[
    {
        "name": "小红",
        "sex": 0,
        "sexName": "女"
    },
    {
        "name": "小明",
        "sex": 1,
        "sexName": "男"
    }
]
~~~

## 执行嵌套填充

当我们有一个嵌套的对象需要填充时，我们需要额外为需要填充的嵌套字段声明一个**拆卸操作**。

比如，`Student` 对象中还嵌有一个需要填充的 `StudentClass` 对象，它需要通过 id 从命名空间为 `student-class` 的数据源容器获取数据源对象的 `name` 属性并填到自己的 `name` 上。

除了正常的为 `StudentClass` 声明装配操作外，我们需要额外的在 `Student` 的 `studentClass` 属性上通过注解声明一个拆卸操作：

~~~java
@RequiredArgsConstructor
@Data
public class Student {
    private final String name;

    @Assemble(
        container = "gender", // 指定使用的命名空间为 gender 的数据源容器
        props = @Mapping(ref = "sexName") // 将根据 sex 取得值映射到 sexName 上
    )
    private final Integer sex;
    private String sexName;
    
    // 声明一个拆卸操作，拆卸后需要填充的对象类型为 StudentClass
    // 字段类型可以是单个对象，数组或者 Collection 集合
    @Disassemble(type = StudentClass.class)
    private final StudentClass studentClass; 
}

@RequiredArgsConstructor
@Data
public class StudentClass {
    @Assemble(container = "student-class", @Props = @Mapping("name"))
    private final Integer id;
    private String name;
}
~~~

上述配置表示，在执行装配操作前，我们需要先将 `Student` 中的 `StudentClass` 取出摊平，然后再统一完成所有待处理的 `Student` 和 `StudentClass` 对象中的装配操作。

我们依然在项目启动后执行下述代码：

~~~java
OperateTemplate operateTemplate = SpringUtil.getBean(OperateTemplate.class);
List<Student> students = Arrays.asList(
    new Student("小红", "0", new StudentClass(1)), new Student("小明", "1", new StudentClass(2))
);
operateTemplate.execute(students);
~~~

执行后，`students` 中的 `Student` 对象及嵌套的 `StudentClass` 对象将会被填充：

~~~json
[
    {
        "name": "小红",
        "sex": 0,
        "sexName": "女"
        "studentClass": {
            "id": 1,
            "name": "一年1班"
        }
    },
    {
        "name": "小明",
        "sex": 1,
        "sexName": "男"
        "studentClass": {
            "id": 2,
            "name": "一年2班"
        }
    }
]
~~~
