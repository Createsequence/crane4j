## 安装

在非 spring 环境中，引入 `crane4j-core` 模块即可：

~~~xml
<dependency>
    <groupId>cn.crane4j</groupId>
    <artifactId>crane4j-core</artifactId>
    <version>${last-version}</version>
</dependency>
~~~

## 基于默认配置运行

在非 spring 环境中，由于没有 IOC ，因此 `crane4j` 的单例组件需要由用户自行实例化并组装。

不过 `crane4j` 的全局配置类 `SimpleCrane4jGlobalConfiguration` 有默认提供 `create` 工厂方法用于创建一个最基本的运行配置：

~~~java
// 创建一个默认配置类
SimpleCrane4jGlobalConfiguration configuration = SimpleCrane4jGlobalConfiguration.create(Collections.emptyMap());
// 基于默认的配置解析器与执行器创建一个 OperateTemplate
OperateTemplate template = new OperateTemplate(
    configuration.getBeanOperationsParser(BeanOperationParser.class),
    configuration.getBeanOperationExecutor(BeanOperationExecutor.class),
    configuration.getTypeResolver()
);
~~~

用户需要自己管理 `Crane4jGlobalConfiguration` 与 `OperateTemplate` 实例，前者里面已经配置好了各种基本组件，而后者则可以直接用于完成填充操作。

**启动扩展功能**

同样的，由于缺少 AOP 与后处理等功能支持，因此一些附加功能需要用户自行参考下述组件的测试用例启用：

- 自动填充方法入参：`MethodArgumentAutoOperateSupport`；
- 自动填充方法返回值：`MethodResultAutoOperateSupport`；
- 方法数据源容器 `ContainerMethodAnnotationProcessor`：
  1. 适配 `@ContainerMethod` 注解的方法：`DefaultMethodContainerFactory` ；
  2. 适配 `@CacheContainer` 注解的方法：`CacheableMethodContainerFactory`；
- 自动适配容器为缓存容器：`DefaultCacheableContainerProcessor`；

## 配置数据源容器

在 `crane4j` 中，一个数据源对应一个**数据源容器**，因此在填充前需要先准备好对应的数据源容器。

这里我们简单配置一个命名空间为 `gender` 的数据源容器，它将根据 0 或 1 返回对应的性别名称：

~~~java
// 注册性别信息数据源
Map<Integer> sources = new HashMap<>();
sources.put(0, "女");
sources.put(1, "男");
Container<String> genderContainer= ConstantContainer.forMap("gender", sources);
~~~

接着，我们将其注册到前面创建的全局配置类 `SimpleCrane4jGlobalConfiguration` 中：

~~~java
Crane4jApplicationContext context = // 用户自己保存的 SimpleCrane4jGlobalConfiguration 实例
context.registerContainer(genderContainer);
~~~

:::tip

- 注册数据源的步骤我们也可以放到 `ApplicationRunner` 或者被 `@PostConstruct` 注解的回调方法中；
- 处理简单的本地缓存外，`crane4j` 还支持创建其他种类的数据源容器，具体参见后文数据源容器部分内容；

:::

## 配置装配操作

在 `crane4j` 中，对某个对象的填充行为被称为**装配操作**，我们可以通过在类或者类的属性上添加注解来配置一个装配操作。

比如，我们在 `Student` 中声明一个装配操作：

- 基于 **key 字段**  `sex` 完成操作，即根据 `sex` 字段的值去查找关联数据；
- 从命名空间为 `gender` 的**数据源容器**获取关联数据；
- 将获得的关联数据源直接赋值给**引用字段** `sexName`；

~~~java
@RequiredArgsConstructor // 使用 lombok 生成 get 方法和构造器
@Getter
@Setter
public class Student {
    private final String name;

    @Assemble(
        container = "gender", // 指定使用的命名空间为 gender 的数据源容器
        props = @Mapping(ref = "sexName") // 将根据 sex 取得值映射到 sexName 上
    )
    private final Integer sex;
    private String sexName;
}
~~~

上述配置即表示 `根据 sex 从刚配置的 `gender` 数据源容器中查找对应的男/女名称，并映射到 `sexName` 字段上` 这样一个操作。

:::tip

- `@Assemble` 注解用于声明一次填充操作，具体参见后文[装配操作](./../operation/3.1.声明装配操作.md)一节；
- `@Mapping` 用于指明数据源对象上的字段要如何映射到待处理对象的字段上，具体参见后文[字段映射](./../operation/3.4.配置字段映射.md)一节；

:::

## 执行装配操作

在项目启动后，用户需要获得之前创建的填充工具类 `OperateTemplate` 去填充我们已经配置过的对象：

~~~java
OperateTemplate operateTemplate  = // 用户自己保存的 OperateTemplate 实例
List<Student> students = Arrays.asList(
    new Student("小红", 1), new Student("小明", 2)
);
operateTemplate.execute(students);
~~~

在执行后，`students` 中对象的 `sexName` 将根据 `sex` 字段的值被填充：

~~~java
[
    {
        "name": "小红",
        "sex": 0,
        "sexName": "女"
    },
    {
        "name": "小明",
        "sex": 1,
        "sexName": "男"
    }
]
~~~

## 执行嵌套填充

当我们有一个嵌套的对象需要填充时，我们需要额外为需要填充的嵌套字段声明一个**拆卸操作**。

比如，`Student` 对象中还嵌有一个需要填充的 `StudentClass` 对象，它需要通过 id 从命名空间为 `student-class` 的数据源容器获取数据源对象的 `name` 属性并填到自己的 `name` 上。

除了正常的为 `StudentClass` 声明装配操作外，我们需要额外的在 `Student` 的 `studentClass` 属性上通过注解声明一个拆卸操作：

~~~java
@RequiredArgsConstructor
@Data
public class Student {
    private final String name;

    @Assemble(
        container = "gender", // 指定使用的命名空间为 gender 的数据源容器
        props = @Mapping(ref = "sexName") // 将根据 sex 取得值映射到 sexName 上
    )
    private final Integer sex;
    private String sexName;
    
    // 声明一个拆卸操作，拆卸后需要填充的对象类型为 StudentClass
    // 字段类型可以是单个对象，数组或者 Collection 集合
    @Disassemble(type = StudentClass.class)
    private final StudentClass studentClass; 
}

@RequiredArgsConstructor
@Data
public class StudentClass {
    @Assemble(container = "student-class", @Props = @Mapping("name"))
    private final Integer id;
    private String name;
}
~~~

上述配置表示，在执行装配操作前，我们需要先将 `Student` 中的 `StudentClass` 取出摊平，然后再统一完成所有待处理的 `Student` 和 `StudentClass` 对象中的装配操作。

我们依然在项目启动后执行下述代码：

~~~java
OperateTemplate operateTemplate = // 用户自己保存的 OperateTemplate 实例
List<Student> students = Arrays.asList(
    new Student("小红", "0", new StudentClass(1)), new Student("小明", "1", new StudentClass(2))
);
operateTemplate.execute(students);
~~~

执行后，`students` 中的 `Student` 对象及嵌套的 `StudentClass` 对象将会被填充：

~~~json
[
    {
        "name": "小红",
        "sex": 0,
        "sexName": "女"
        "studentClass": {
            "id": 1,
            "name": "一年1班"
        }
    },
    {
        "name": "小明",
        "sex": 1,
        "sexName": "男"
        "studentClass": {
            "id": 2,
            "name": "一年2班"
        }
    }
]
~~~