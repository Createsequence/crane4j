## 概述

通过在方法或者类上添加 `@ContainerMethod` 注解，我们可以将任意的方法适配为方法数据源容器 `MethodInvokerContainer`，当调用容器时，将会自动调用方法并且返回方法执行结果作为数据源对象。

## 2.5.1.声明方法数据源

**直接声明**

我们可以直接在类上添加 `@ContainerMethod` 注解，声明该方法为一个数据源。

~~~java
@ContainerMethod(
    namespace = "onoToOneMethod",
    resultType = Foo.class, resultKey = "id", // 返回的数据源对象类型为 Foo，并且需要按 id 分组
)
public Set<Foo> onoToOneMethod(List<String> args) {
    // do something
}
~~~

在 spring 环境中，当项目启动时后处理阶段该方法会被扫描并注册成 `namespace` 为 `onoToOneMethod` 的数据源容器。

**间接声明**

我们也可以在类上声明，不过需要额外使用 `@Bind` 注解去绑定方法，比如：

~~~java
// 父类
public class SuperClass {
    public Set<Foo> onoToOneMethod(List<String> args) {
        // do something
    }
}

// 子类
@ContainerMethod(
    namespace = "onoToOneMethod",
    resultType = Foo.class, resultKey = "id", // 返回的数据源对象类型为 Foo，并且需要按 id 分组
    bind = @Bind(value = "onoToOneMethod", paramTypes = List.class) // 通过@Bind注解绑定指定方法
)
public class ChildClass extend SuperClass {}
~~~

在上述示例中，我们在 `ChildClass` 中将父类 `SuperClass` 中的 `onoToOneMethod` 方法声明为一个方法数据源容器。

:::tip

- 方法可以是实例或静态；
- 方法可以无参或有参方法，若是有参方法，则第一个参数必须为 `Collection` 类型；
- 方法必须有返回值， 可以是 `resultType` 类型对应的对象、对象的数组、对象的 `Collection` 集合，或者已按 `key` 分组的 `Map` 集合；

:::

## 2.5.2.对结果分组

由于数据源容器的返回值需要按 key 分组，因此注解必须通过 `resultType` 和 `resultKey` 指定获取数据源对象后用于分组的 key 字段。

一般情况下，我们认为方法数据源容器返回的对象总是与 key 一对一的，不过也有需要一对多分组或者不需要分组的情况，此时则可以通过 `type` 属性指定映射类型，改变结果的分组方式。

**按key值一对一分组**

即一个输入的 key 值对应一个数据源对象，类型为 `MappingType.ONE_TO_ONE`，默认就是一对一。

**按key值一对多分组**

即一个输入的 key 值对应一个数据源集合，类型为 `MappingType.ONE_TO_MANY`。

比如，我们有一个方法根据 `classId` 获取 `student` 对象的方法，我们希望它返回的 `studen` 对象可以按 `classId` 分组：

~~~java
@ContainerMethod(
    namespace = "student-class",
    resultType = Student.class, resultKey = "classId", // 返回的数据源对象类型为 Foo，并且需要按 id 分组
    type = MappingType.ONE_TO_MANY // 返回数据源对象与待处理对象类型为一对一，即待一个处理对象的 key 值对应一个数据源对象的 key
)
public List<Student> getStudentByClassIds(List<Integer> classIds) {
    // do something
}
~~~

则该方法适配为数据源容器后，将会接受 `classId` 集合，并返回按 `classId` 分组的`student` 对象（`Map<Integer, List<Student>>`）。

**无需分组**

有时候，我们的方法返回值已经是一个按需要的 `key` 值分好组的 `Map` 集合了，这种情况可以指定类型为 `MappingType.MAPPED`，表明该方法已经完成映射，无需再进行额外的分组：

~~~java
@ContainerMethod(namespace = "student", type = MappingType.MAPPED)
public Map<Integer, Student> getStudentByIds(List<Integer> ids) {
    // do something
}
~~~

比如上述示例中，`getStudentByIds` 返回值已经是按 `id` 分组的 `Student` 对象集合了，因此无需再进行额外的分组，也就不需要再指定 `resultType` 和 `resultKey`。

:::tip

`resultKey` 默认支持链式操作符，即通过 `xx.xx.xx` 的方式访问内部对象的属性。

:::

## 2.5.4.数据源容器工厂

参照 spring 处理 `@EventListener` 注解的方式，我们基于注解处理器 `MethodContainerAnnotationProcessor` 处理带有`@ContainerMethod`注解的方法。它将会选择一个优先级最高的数据源容器工厂 `MethodContainerFactory` 将被注解方法适配为数据源容器。

`crane4j` 默认提供了 `DefaultMethodContainerFactory`和`CacheableMethodContainerFactory` 两种工厂，分别用于被 `@ContainerMethod` 注解的方法和被 `@ContainerCache` 注解的方法。

用户也可以通过实现 `MethodContainerFactory` 接口并提高优先级，然后将其声明到 spring 上下文中自动注册、或者手动注册到注解处理器里面，以便实现自己的逻辑。

## 2.5.5.注册方法数据源容器

在 spring 环境中，只要方法所在的 bean 被 spring 管理，则在后处理阶段，这些方法都将会被自动适配为方法数据源容器，并注册全局配置中。

在非 spring 环节中，用户也可以通过 `MethodContainerAnnotationProcessor` 去手动扫描类中方法，并获得方法数据源容器：

~~~java
// 配置反射工厂与注解查找器
PropertyOperator propertyOperator = new ReflectPropertyOperator();
AnnotationFinder annotationFinder = new SimpleAnnotationFinder();
// 配置方法数据源工厂
Collection<MethodContainerFactory> factories = Arrays.asList(
    new DefaultMethodContainerFactory(propertyOperator, annotationFinder),
    new CacheableMethodContainerFactory(propertyOperator, annotationFinder, new ConcurrentMapCacheManager(ConcurrentHashMap::new))
);
// 扫描类中方法，创建方法数据源
MethodContainerAnnotationProcessor processor = new MethodContainerAnnotationProcessor(new SimpleAnnotationFinder(), factories);
Collection<Container<Object>> containers = processor.process(foo, Foo.getClass());

// 获取全局上下文
Crane4jGlobalConfiguration configuration = SpringUtils.getBean(Crane4jGlobalConfiguration.class);
containers.forEach(configuration::registerContainer);
~~~