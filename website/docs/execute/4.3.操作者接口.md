## 操作者接口

操作者接口的设计灵感来自于 `MapStruct` 的 `Mapper` 接口，它是手动填充的一种补充，比如，在业务场景中，我们可能会遇到一些不方便直接在类上配置注解的情况下：

- 虽然有点离谱，但是用于填充的对象就是个 `JSONObject` / `Map`，压根就没有对应的 Java 类；
- 填充的对象字段非常像，但是它们确实不是一个类，又不想两个类都重复一遍配置，也不想搞通用组合注解；
- 你别管那么多，反正就是不方便在类上添加配置；

这种情况下，除了超级麻烦的手动构建一个 `BeanOperations` 再去调用执行器外，还可以通过操作者接口来完成这类操作。

## 4.3.1.基本使用

比如，我们先在一个接口上添加 `@Operator` 注解声明其为操作者接口，然后我们在抽象方法上直接使用 `@Assemble` 注解配置装配操作，就像在类或者类属性上配置的那样：

~~~java
@Operator
private interface OperatorInterface {
    @Assemble(key = "id", container = "test", props = @Mapping(ref = "name"))
    void operate(Collection<Map<String, Object>> targets);
}
~~~

然后，我们使用代理工厂 `OperatorProxyFactory` 为其生成代理类，使其变为真正的具备填充能力的操作者对象：

~~~java
// 创建代理工厂，若在 spring 环境直接从 spring 上下文获取即可
OperatorProxyFactory operatorProxyFactory = new OperatorProxyFactory(
    SimpleCrane4jGlobalConfiguration.create(), 
    new SimpleAnnotationFinder(), 
    Collections.singletonList(new DefaultProxyMethodFactory()) // 指定方法解析器为 DefaultProxyMethodFactory
);

// 创建代理类，并调用抽象方法完成填充操作
OperatorInterface operator = operatorProxyFactory.get(OperatorInterface.class);
Collection<Map<String, Object>> targets = IntStream.rangeClosed(0, 5).mapToObj(id -> {
    Map<String, Object> target = new HashMap<>();
    target.put("id", id);
    return target;
}).collect(Collectors.toList());
operator.operate(targets);
~~~

当调用 `operate` 方法后，我们入参的 `targets` 将会根据 `operate` 方法上配置的操作进行填充。

:::tip

- 所有 `AssembleXXX` 格式的操作配置注解都支持在方法上使用，因此操作者接口的配置方式与基于类或属性的方式基本一致；
- 配置解析器 `BeanOperationParser` 支持从任何 `AnnotatedElement` 的注解上解析并获得 `BeanOperations` 配置对象，不局限于 `Class` 或者 `Method`，操作者接口便得益于此，你也可以借此扩展处更多玩法；

:::

## 4.3.2.指定执行器和解析器

和 `@AutoOperate` 类似，`@Operator` 接口同样也可以指定用于执行操作的执行器和配置解析器：

~~~java
@Operator(
    executor = OrderedBeanOperationExecutor.class,
    parser = TypeHierarchyBeanOperationParser.class
)
private interface OperatorInterface {
    @Assemble(key = "id", container = "test", props = @Mapping(ref = "name"))
    void operate(Collection<Map<String, Object>> targets);
}
~~~

## 4.3.3.临时数据源

结合动态数据源容器提供者 `DynamicSourceContainerProvider`，操作者接口运行将方法作为一次填充操作的临时数据源：

~~~java
@Operator
private interface OperatorInterface3 {
    @Assemble(
        key = "id", container = "test", props = @Mapping(ref = "name"),
        containerProvider = ThreadContextContainerProvider.class
    )
    void operate(Collection<Map<String, Object>> targets, @ProvideData("test") Map<Integer, ?> tempData);
}
~~~

比如，在上文，我们在抽方法上配置了一个基于命名空间为 `test` 的数据源容的装配操作，然后我们声明该容器由动态数据源容器提供者 `ThreadContextContainerProvider` 提供，最后我们在一个**类型为 Map 的方法参数**上使用 `@ProvideData` 注解表明 `test` 容器需要在本次操作中使用 `tempData` 作为它的临时数据源。

当我们使用时：

~~~java
OperatorInterface operator = operatorProxyFactory.get(OperatorInterface.class);

// 声明一个待处理对象
Map<String, Object> target = new HashMap<>();
target.put("id", 1);
Collection<Map<String, Object>> targets = Collections.singletonList(target);

// source 将作为临时数据源
Map<Integer, Object> source = new HashMap<>();
source.put(1, "name1");

// 填充待处理对象，数据源容器 test 将会直接返回 source 作为本次填充的数据源对象 
operator.operate(targets, source);
Assert.assertEquals("name1", target.get("name"));
~~~

此外，作为临时数据源的**参数类型也可以是 `DataProvider` 函数式接口**：

~~~java
@Operator
private interface OperatorInterface3 {
    @Assemble(
        key = "id", container = "test", props = @Mapping(ref = "name"),
        containerProvider = ThreadContextContainerProvider.class
    )
    void operate(Collection<Map<String, Object>> targets, @ProvideData("test") DataProvider<Integer, ?> provider);
}
~~~

该接口实际上为一个接受 key 的`Collection` 集合，并返回按 key 分组的数据源对象 `Map` 集合的 `Function` 接口 `Function<Collection<K>, Map<K, V>>`。

`@ProvideData` 也可以不指定 `value`，此时将会直接寻找注解的参数名对应的容器。比如：

~~~java
@Operator
private interface OperatorInterface3 {
    @Assemble(
        key = "id", container = "test", props = @Mapping(ref = "name"),
        containerProvider = ThreadContextContainerProvider.class
    )
    void operate(Collection<Map<String, Object>> targets, @ProvideData DataProvider<Integer, ?> test); // 不指定value，则默认按参数名
}
~~~

:::tip

- 临时容器的配置是比较繁琐的，你可以借助高级特性中的组合注解简化注解配置；
- 抽象方法暂时还不支持指定本次执行的操作组，后续版本将会考虑添加一个注解，允许用户直接将操作组作为参数传入；

:::

## 4.3.4.自动扫描与依赖注入

就像 `Mybatis` 一样，在 spring 环境中，用户可以在启动类或配置类上添加 `@OperatorScan` 注解，便利的批量扫描、添加或排除操作者接口：

~~~java
@OperatorScan(
	scan = {"cn.crane4j.example.operators", "cn.crane4j.spring.example.operators"},
    includes = FooOperator.class, excludes = ExcludeOpeator.class
)
@Configuration
protected class Application {
}
~~~

在项目启动后，将会自动为接口创建 `BeanDefinitio`，并在 spring 容器中创建对应的 `Bean`，因此用户也可以像使用 `Mybatis` 的 `Mapper` 那样，通过依赖注入使用操作接口，或者在操作者上使用 Spring 的后处理回调或者 AOP 功能：

~~~Java
@Component
public class FooService {
    @Autowrite
    private FooOperator operator;
} 
~~~

## 4.3.5.代理方法工厂

与配置解析器中的注解解析器 `OperationAnnotationResolver` ，还有处理方法数据源容器的 `MethodContainerFactory` 一样，操作者接口中抽象方法的解析同样基于策略模式。

操作者的代理方法工厂 `OperatorProxyFactory.ProxyMethodFactory` 默认提供了两种实现：

- `DefaultProxyMethodFactory`：默认的代理方法工厂，支持处理所有有参方法；
- `DynamicSourceProxyMethodFactory`：动态数据源方法工厂，用于支持参数带有 `@ProvideData` 注解的方法，在 spring 环境用户可以自行创建该 Bean，以便选择该工厂要依赖哪一种上下文实现的动态数据源容器提供者；

如果有必要，用户也可以自行实现接口，并提高工厂的优先级替换默认策略。

在 spring 环境中，仅需将自定义工类声明到 spring 上下文即可完成自动注册，在非 spring 环境，用户需要在创建代理工厂 `OperatorProxyFactory` 时将放入所需的方法工厂。
