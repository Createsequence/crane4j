## 3.1.1.声明装配操作

### 3.1.1.1.在属性上声明

通常情况下，可以使用 `@Assemble` 在某个键字段上声明装配操作，如下所示：

```java
public class Student {
    @Assemble(container = "student", props = @Mapping(src = "studentName", ref = "name"))
    private Integer id;
    private String name;
}
```

上述配置表示以下操作：

1. 使用 `id` 字段的值；
2. 从命名空间为 `student` 的数据源容器中获取数据源对象；
3. 获取与 `id` 字段值对应的数据，将数据源对象中的 `studentName` 字段值映射到 `name` 字段上；

如果 `src` 和 `ref` 指向的字段相同，也可以直接使用 `value` 属性同时指定，例如：

```java
public class Student {
    @Assemble(container = "student", props = @Mapping("name")) // source.name -> target.name
    private Integer id;
    private String name;
}
```

### 3.1.1.2.在类上声明

在无法直接修改父类的情况下，可以在类上添加注解来声明装配操作，例如：

```java
// 直接声明
@Assemble(key = "id", container = "student", props = @Mapping(src = "studentName", ref = "name"))
public class Student {
    private Integer id;
    private String name;
}
```

与在属性上直接声明不同，需要通过 `key` 属性绑定相应的键字段。

:::tip

- 在父类或父类属性中声明的操作也会被子类继承。
- `key` 属性默认支持使用 `xx.xx.xx` 格式的链式操作符访问嵌套对象的属性。

:::

## 3.1.2.声明多重装配

有时候，我们需要在同一个键上声明多次装配操作，这是允许的，例如：

```java
public class UserVO {
    @Assemble(container = "user", props = @Mapping(src = "role", ref = "role"), groups = "admin")
    @Assemble(container = "user", props = @Mapping(src = "name", ref = "name"), groups = {"base", "admin"})
    private Integer id;
    private String name;
    private String role;
}
```

:::tip

无需担心多次查询数据源的问题，默认的执行器 `DisorderedBeanOperationExecutor` 会将相同容器的操作合并执行，以减少数据源容器的调用次数。

:::

## 3.1.3.动态表达式

在 `@Assemble` 注解的 `container` 属性中，可以使用与 `@Value` 相似的方式引用配置文件的属性，例如：

```java
public class Foo {
    @Assemble(container = "${custom.namespace}")
    private String name;
    private String alias;
}
```

也可以使用SpEL表达式，例如：

```java
public class Foo {
    @Assemble(container = "${custom.namespace} + '$$defaultProvider'")
    private String name;
    private String alias;
}
```

:::tip

此功能仅在Spring环境中支持。

:::