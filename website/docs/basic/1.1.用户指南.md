![image-20230220150040070](./image-20230220150040070.png)

## 1.1.1.为什么写？

`crane4j` 的前身是 [`crane`](https://github.com/Createsequence/crane)，而 `crane` 的前身来自在公司写的一个字段填充框架。当时恰好个人负责的业务有大量重复的字段填充的需求，这些字段跟核心业务无关，就是重复的关联查询，但是又无处不在，实在厌倦了联查和手动塞值的我，抽了点时间在项目里面加了一个基于 `MybatisPlus` 自动查询并填充字段值的小插件。

随着时间的推移，这个插件的功能越来越丰富，又支持了枚举和常量转换，接着又是基于切面的自动填充......最后又独立成了一套框架，这就是 crane 的前身，至今仍然在生产环境中发光发热。

去年年前的时候，我抽时间重构了这个框架的代码，并且把它传到了 `Gitee`，这个项目就是 [`crane`](https://github.com/Createsequence/crane)。`crane` 更新了大概半年多，功能渐渐稳定，不过早期设计不足导致扩展困难的问题也越来越明显。重新梳理的功能后，我决定基于 `crane` 的功能和一些概念再进行一次彻底的重构，于是就有了现在的 `crane4j`。

相比起前辈 `crane`，`crane4j` 的代码更健壮，设计更合理，功能更强大，使用更灵活。

## 1.1.2.它解决了什么问题？

“根据 A 的 key 值拿到 B，再把 B 的属性映射到 A”，这就是 `crane4j` 的核心功能。

在面向业务的开发中经常会遇到一些繁琐的数据组装工作，这些工作一般相对核心业务逻辑较为独立，但是由于数据来源五花八门，且填充的字段与类型也不尽相同，导致往往需要编写大量的样板代码处理。

`crane4j` 旨在为了解决这种烦恼而生，它允许开发者通过精简的配置与极少的代码，即可从不同数据源中获得不同类型、不同名称的字段并填充到指定的对象里，组件化的设计也允许开发者灵活的植入自定义的逻辑。

## 1.1.3.它有什么特性？

- **多样的数据源支持**：支持将枚举、普通键值对缓存，甚至实例方法或静态方法作为数据源，也支持通过简单的自定义扩展兼容更多类型的数据源，并且对所有类型数据源都提供缓存支持；
- **强大的字段映射能力**：通过注解即可完成不同类型字段之间映射自动转换，支持模板、排序、分组、自动填充嵌套对象等等功能，除 JDK 原生反射外还支持更快的字节码调用；
- **高度的可扩展性**：所有主要组件均可由用户自由替换，配合 Spring 的依赖注入可实现轻松优雅的完成自定义扩展。
- **丰富的可选功能**：提供包括方法返回值与方法入参参数的自动填充，多线程填充，自定义符合注解以及表达式等可选功能；

在后续，将会陆续完成包括 JSON 对象的字段动态填充/替换、基于 redis 的数据源缓存、基于 ~~Myabtis/MybatisPlus~~（已完成）、JPA 等 ORM 框架的数据源自动适配等新功能。

## 1.1.4.如何使用？

想要快速体验 `crane4j`，请阅读快速开始一章，如果想要进一步了解和使用 `crane4j`，可以按推荐目录顺序阅读文档。

源码中记录每个类都有对应的测试用例，如果仍然感觉不好理解，可以在把源码中的示例模块 `crane4j-example` ([Gitee](https://gitee.com/CreateSequence/crane4j/tree/dev/crane4j-example) / [GitHub](https://github.com/opengoofy/crane4j/tree/dev/crane4j-example))  拉到本地运行一下，里面有针对某些比较复杂的功能的集成测试，或许会有助于理解和使用对应功能。
