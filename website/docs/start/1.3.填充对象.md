## 1.3.1.配置填充操作

在前文，我们配置并注册了一个命名空间为 `number` 的数据源，现在可以基于它进行填充了。

在最开始，你需要通过注解的方式，在类中描述如何将各种数据按指定的规则填充到对象中，这个步骤在 cranej4 中称为 **“装配” （Assemble）**。

**因此，当我们需要基于某一个字段完成一次填充操作时，就需要声明一个装配操作**。

比如：

~~~java
@ToString
@RequiredArgsConstructor // 使用 lombk 生成构造器
public class Foo {
    @Assemble(container = "number", props = @Mapping(ref = "numName"))
    private final Integer num;
    private String numName;
}
~~~

上述配置表示，当进行填充时：

+ 从全局配置对象中找到命名空间为 `number` 的数据源容器；
+ 使用 `Foo` 对象的 `num` 属性从数据源中获取对应值；
+ 将值映射到 `Foo` 对象的 `numName` 属性；

此外，你也可以将配置放在类而非属性上：

~~~java
@Assemble(
    key = "num", // 绑定到 num 属性
    container = "number", props = @Mapping(ref = "numName")
)
@ToString
@RequiredArgsConstructor // 使用 lombk 生成构造器
public class Foo {
    private final Integer num;
    private String numName;
}
~~~

除了需要额外指定 `key` 外，两者的效果是完全一致的。

:::tip

具体内容，请参见后文“操作配置”一章。

:::

## 1.3.2.手动填充

在完成对 `Foo` 的配置后，你可以通过 `OperateTemplate` 对一组对象进行填充。

**获得 OperateTemplate**

在 Spring 环境中，你可以直接从 Spring 容器中获得 `OperateTemplate`：

~~~java
@Component
public class Bean {
    @Autowired // 直接通过依赖注入获得
    private OperateTemplate operateTemplate;
}
~~~

在非 Spring 环境中，你可以通过最开始创建的全局配置对象创建一个 `OperateTemplate`：

~~~java
Cranej4GlobalConfiguration configuration = SimpleCrane4jGlobalConfiguration.create(); // 在最开始创建的全局配置对象
OperateTemplate template = new OperateTemplate(
    configuration.getBeanOperationsParser(BeanOperationParser.class),
    configuration.getBeanOperationExecutor(BeanOperationExecutor.class),
    configuration.getTypeResolver()
);
~~~

**执行填充**

你可以用 `OperateTemplate`  对单个或一批具有相同类型的对象进行填充，当填充时，cranej4 会自动解析类上的注解配置，并根据配置完成填充：

~~~java
List<Foo> foos = Arrays.asList(new Foo(1), new Foo(2), new Foo(3));
operateTemplate.execute(foos);
System.out.println(foos);
// [Foo(num=1, numName="one"), Foo(num=2, numName="two"), Foo(num=3, numName="three")]
~~~

在执行后，`num` 在数据源中对应的值被填充到对象的 `numName` 属性上。

:::tip

具体内容，请参见后文 “执行操作-手动填充” 部分内容。

:::

## 1.3.3.自动填充

在 Spring 环境中，你也可以基于切面自动的填充方法返回值，默认支持单个对象、数组或者任意的 `Collection` 集合：

~~~java
@AutoOperate(type = Foo.class)
public List<Foo> method1() {
    return Arrays.asList(new Foo(1), new Foo(2), new Foo(3)); // 填充对象集合
}

@AutoOperate(type = Foo.class)
public Foo[] method2() {
    return new Foo[]{ new Foo(1), new Foo(2), new Foo(3) }; // 填充对象数组
}

@AutoOperate(type = Foo.class)
public Foo method3() {
    return new Foo(1); // 填充单个对象
}
~~~

除返回值外，也可以填充方法的入参：

~~~java
public void method(@AutoOperate(type = Foo.class) Foo foo) { // 填充方法入参
    // do something
}
~~~

如果方法的返回值或参数类型是泛型，你也可以不指定类型，而让 crane4j 自动推断：

~~~java
@AutoOperate // 在填充时自动推断类型
public T method() {
    // return something
}
~~~

有时候，方法的返回值并不是真正需要填充的对象，那么你可以对外层对象进行提取，比如：

~~~java
@RequiredArgsConstructor
@Getter
public class Result<T> {
    private final T data;
}

@AutoOperate(
    on = "data", // 从返回值 Result 中提取 data 属性
    type = Foo.class // 实际填充类型为 Foo，也就是 data 属性对应的数据
)
public Result<Foo> method3() {
    return new Result<>(new Foo(1));
}
~~~

:::tip

具体内容，请参见后文 “执行操作-自动填充” 部分内容。

:::
