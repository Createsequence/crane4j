## 概述

在`crane4j`中，可以基于 Spring AOP 的切面来实现自动填充方法的参数和返回值，这种方式称为**自动填充**。

## 4.2.1.声明自动填充

### 4.2.1.1.填充方法返回值

基于 `SpringAOP`，当我们在方法上添加 `@AutoOperate` 后，切面类 `MethodResultAutoOperateAdvisor` 即可在方法返回时对返回值进行自动填充：

~~~java
@AutoOperate(type = Foo.class)
public List<Foo> getFooList() {
    // do nothing
}
~~~

返回值类型可以是单个对象、对象数组或对象的 `Collection` 集合。

### 4.2.1.2.自动填充方法参数

基于 `SpringAOP`，当我们在方法上添加 `@ArgAutoOperate` 后，切面类 `MethodArgumentAutoOperateAdvisor` 即可在方法执行前对入参进行自动填充：

~~~java
// 1.可以注解在参数上
@ArgAutoOperate
public void getFooList(@AutoOperate(type = Foo.class) Foo foo) {
    // do nothing
}

// 2.可以注解在方法上
@ArgAutoOperate(@AutoOperate(value = "foo", type = Foo.class))
public void getFooList(Foo foo) {
    // do nothing
}
~~~

与返回值填充类似，填充的数据可以是单个对象、对象数组或对象的集合类型参数，并支持所有返回值自动填充功能的全部功能。

## 4.2.2.自动类型推断

在某些情况下，无法在编译期确定要填充的对象类型。此时，可以不指定 `type` 属性，而是在执行拆卸操作时动态推断类型：

```java
@AutoOperate // 无法确定填充类型
public List<T> getFooList() {
    // do nothing
}
```

上述示例中，无法在编译期确定 `getFooList` 的返回值类型，因此没有指定 `type` 属性。在执行自动填充操作时，会动态推断类型。

这个功能是通过类型解析器 `TypeResolver` 实现的。用户可以实现 `TypeResolver` 接口来替换默认的类型解析器，以适应特定的需求。

## 4.2.3.包装类提取

有时候，在`Controller`中的方法返回值通常会使用通用响应体进行包装，例如：

~~~java
public class Result<T> {
    private Integer code;
    private T data;
}

@AutoOperate(type = Foo.class)
public Result<List<Foo>> getFooList() {
    // do nothing
}
~~~

实际上，需要填充的对象并不是`Result`本身，而是`Result`中的`data`字段。除了将`Result`作为填充对象并在`data`上添加`@Disassemble`注解进行拆卸外，还可以直接通过`on`属性提取特定属性值进行填充。

例如：

~~~java
@AutoOperate(type = Foo.class, on = "data")
public Result<List<Foo>> getFooList() {
    // do nothing
}
~~~

:::tip

`on`属性默认支持链式操作符，即通过`xx.xx.xx`的方式访问内部对象的属性。
例如，对于常见的`Result<PageInfo<Foo>>`，可以使用`on = data.list`来获取嵌套在 `PageInfo.list` 中的待处理数据。

:::

## 4.2.4.应用条件表达式

通过注解的 `condition` 属性，可以设置应用条件的表达式。在执行填充之前，将根据表达式的计算结果确定是否执行该次填充。

例如：

~~~java
@AutoOperate(type = Foo.class, condition ="#type != 1 && ${config.enable-fill-foo}")
public List<Foo> getFoo(Integer type) {
    // do nothing
}
~~~

上述示例表示只有当`type`不等于 `1` 且配置文件中的 `config.enable-fill-foo` 为 `true` 时，才会执行填充操作。

默认的表达式引擎是 SpEL 表达式，因此可以在表达式中使用 `#result` 引用返回值，使用 `#参数名` 引用方法的入参。返回值可以是布尔值，也可以是字符串`'true'`或`'false'`。

:::tip

在 Spring 环境中，默认支持 SpEL 表达式，也可以更换表达式引擎以支持其他类型的表达式。

:::

## 4.2.5.分组填充

通过注解的 `includes` 或 `excludes` 属性可以设置本次执行的操作组。例如：

```java
@AutoOperate(type = Foo.class, includes = {"base", "foo"})
public List<Foo> getFoo(Integer type) {
    // do nothing
}
```

在上述示例中，执行填充操作时，只会完成带有 `base` 或 `foo` 组别的装配/拆卸操作。

## 4.2.6.指定执行器

通过注解的 `executor` 属性可以指定本次填充操作的执行器，不同的执行器会对填充操作产生不同的影响。

例如：

~~~java
// @AutoOperate(type = Foo.class, executorType = AsyncBeanOperationExecutor.class)
@AutoOperate(type = Foo.class, executorType = OrderedBeanOperationExecutor.class)
public List<Foo> getFoo(Integer type) {
    // do nothing
}
~~~

在上述示例中，指定的 `OrderedBeanOperationExecutor` 将按照规定的顺序同步执行填充操作，而 `AsyncBeanOperationExecutor` 则支持并发填充。

:::tip

关于执行器，请参照[操作执行器](./4.3.操作执行器.md)一节

:::
