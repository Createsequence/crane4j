## 5.3.1.容器生命周期处理器

参照 Spring 的回调机制，`crane4j` 也提供了特殊的回调接口 `ContainerLifecycleProcessor`，它可以用于感知并干涉容器生命周期中的三个关键节点：

- `whenRegistered`：容器注册前回调，通过该方法获得要注册的容器示例或工厂方法；
- `whenCreated`：容器创建后，通过该方法可以获取创建后即将加入缓存的容器实例；
- `whenDestroyed`：容器销毁后回调，通过该方法可以获得被替换或者删除的容器；

`crane4j` 默认提供了三种处理器实现：

- `CacheableContainerProcessor`：在用户的容器注册前，将会把要注册的容器对象包装并替换具备缓存功能的增强容器；
- `ContainerRegisterLogger`：在容器生命周期的三个关键节点输出相关信息；
- `ContainerInstanceLifecycleProcessor`：用于支持 `Container.Lifecycle` 的 `init` 和 `destroy` 方法。

用户也可以自己实现 `CacheableContainerProcessor`，并将其声明在 spring 上下文中以便自动注册，或者获得全局配置类 `Crane4jGlobalConfiguration` 后，调用 `addContainerLifecycleProcessor` 方法手动注册。

## 5.3.2.容器的生命周期回调

在 `crane4j` 中，容器本身具备针对自身生命周期的回调方法。为了使用容器的声明周期回调方法，你需要让实现类实现 `Container.Lifecycle` 接口，并在实现类中实现相应的回调方法。

以下是一个示例：

```java
@Component
@Getter
@RequiredArgsConstructor
public class Foo implements Container<String>, Container.Lifecycle {
    private final String namespace = "AllDictContainer";
    private final DictService dictService;
    private Map<String, DictDO> allDicts = new HashMap<>();
    
    @Override
    public void init() {
        // 初始化方法
        allDicts = dictService.findAll()
            .stream().collect(Collectors.toMap(DictDO::getId, Function.identity()));
    }
    
    @Override
    public void destroy() {
        // 销毁方法
        allDicts.clear();
    }
    
    @Override
    public Map<String, ?> get(Collection<String> keys) {
        return allDicts;
    }
}
```

在上述示例中，我们创建了一个缓存全部字典项的容器 `Foo`，它实现了 `Container.Lifecycle` 接口。在容器被使用时，会调用 `init()` 方法进行初始化，该方法会查询并缓存字典值。在容器被销毁时，会调用 `destroy()` 方法进行销毁，该方法会清空缓存。

通过实现 `Container.Lifecycle` 接口，并在相应的回调方法中编写初始化和销毁逻辑，你可以在制容器的生命周期中实现自定义的初始化和销毁操作。这对于在容器被使用前后执行一些特定逻辑非常有用。
