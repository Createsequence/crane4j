import{_ as s,c as i,o as a,a4 as n}from"./chunks/framework.CTZgbW0d.js";const t="/crane4j/assets/image-20230220150040070.CYqnNwFK.png",c=JSON.parse('{"title":"简介","description":"","frontmatter":{},"headers":[],"relativePath":"user_guide/what_is_crane4j.md","filePath":"user_guide/what_is_crane4j.md","lastUpdated":1712585141000}'),h={name:"user_guide/what_is_crane4j.md"},e=n('<h1 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h1><p><img src="'+t+`" alt=""></p><p><strong>crane4j 一个简单易用的关联字段填充框架，能够通过简单的注解配置快速根据外键/编码值填充相关字段，支持字典，枚举，方法等多种数据源。</strong></p><p>最初，我在公司开发中遇到了大量重复的字段填充需求，这些需求与核心业务无关，只是一些重复的关联查询操作。我厌倦了频繁的联查和手动赋值，于是花了时间写一个小插件，用于自动查询接口并填充字段值。</p><p>随着时间推移，这个插件功能逐渐丰富，我还加入了对枚举和常量的转换支持，并实现了基于切面的自动填充功能。最终，这个插件发展成了一个独立的内部框架，并在生产环境中广泛使用。</p><p>在 2022 年初，我对这个内部框架进行了重构，并将其上传到 <code>Gitee</code>，它就是 <a href="https://github.com/Createsequence/crane" target="_blank" rel="noreferrer"><code>crane</code></a>。经过半年多的更新，<code>crane</code> 的功能逐渐稳定，但早期设计的不足导致扩展困难。因此，我重新梳理了功能，并决定在保留 <code>crane</code> 功能和概念的基础上进行彻底的重构，这就是现在的 <code>crane4j</code>。</p><h2 id="_1-什么是字段填充" tabindex="-1">1.什么是字段填充？ <a class="header-anchor" href="#_1-什么是字段填充" aria-label="Permalink to &quot;1.什么是字段填充？&quot;">​</a></h2><p>在日常开发中，从缓存或 DB 中查到的数据一般不直接具备所有字段，因此我们往往需要通过外键从各种数据源中 —— 比如 RPC 接口、枚举、字典或者 DB —— <strong>根据外键查询出各种关联信息</strong>，并将其部分字段填充到最终返回的对象上，这种行为实际上就是<strong>字段填充</strong>，或者也可以叫做数据组装或者数据聚合。</p><p>我们以一个典型的“将字典编码转为字典值”为例：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listPerson</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Integer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ids) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 1、根据 id 查询 person 数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    List&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Preson</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; persions </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> personMapper.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listByIds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ids);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 2、将性别枚举按编码分组</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // {key = 0, value = GenderEnum.FEMALE}, {key = 1, value = GenderEnum.MALE}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Map&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">GenderEnum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; genderMap </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Stream.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(GenderEnum.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">values</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">collect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Collectors.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(GenderEnum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">getCode, e </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 3、根据 person 对象中的性别编码，为其设置对应的性别值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    persions.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(person </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Integer genderCode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getGenderCode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        GenderEnum gender </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> genderMap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(genderCode);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        person.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setGenderName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gender.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>listPerson</code> 接口中的第 2、3 步就是非常典型的关联字段填充操作。</p><p>从某种程度来说，crane4j 可以用于完成一切 “根据 A 的 key 值拿到 B，再把 B 的属性映射到 A” 这类需求。</p><h2 id="_2-用-crane4j-怎么做" tabindex="-1">2.用 crane4j 怎么做？ <a class="header-anchor" href="#_2-用-crane4j-怎么做" aria-label="Permalink to &quot;2.用 crane4j 怎么做？&quot;">​</a></h2><p>当引入 crane4j 后，我们可以通过相对简洁的注解描述上述操作，并将此逻辑从主业务流程中剥离，以便让开发者更加集中于核心业务逻辑的开发：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AutoOperate</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listPerson</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Integer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ids) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> personMapper.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listByIds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ids);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Data</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AssembleEnum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GenderEnum.class, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">enumKey</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;code&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 指定枚举类，并按字典值分组</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        props</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Mapping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">src</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ref</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;genderName&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将枚举的 name 映射到 foo 的 genderName 属性</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    )</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Integer genderCode;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String genderName;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>等到方法调用后，crane4j 将会自动的完成填充，效果与执行之前的代码完全一致。</p><h2 id="_3-为什么需要-crane4j" tabindex="-1">3.为什么需要 crane4j？ <a class="header-anchor" href="#_3-为什么需要-crane4j" aria-label="Permalink to &quot;3.为什么需要 crane4j？&quot;">​</a></h2><p><strong>字段填充是一个广泛存在的需求，而 crane4j 则是针对它的一套完善的解决方案。</strong></p><p>crane4j 有着详细的注释和文档，完善的测试用例，灵活而直观的 API，通过引入 crane4j，你可以在避免“重复造轮子”的前提下，通过更少的代码搞定各种关联字段填充的需求。并且，你还可以通过 crane4j 处理比示例更复杂的各种情况，包括且不限于下述场景：</p><ul><li><strong>同时存在的复数操作</strong>：可能同时有多种类型的数据需要填充，比如各种详情页中，我们可能需要填充大量的关联数据；</li><li><strong>复杂的数据结构</strong>：填充的对象可能是一个嵌套的树形结构，需要递归的填充嵌套的数据；</li><li><strong>繁多的数据源</strong>：填充的数据源可能多种多样，比如有的通过 RPC 接口获取，有的通过 ORM 框架获取，有的则从本地缓存中获取；</li><li><strong>可选的字段填充</strong>：相同的数据源在不同的场景下填充的字段可能不同，比如同样是用户查询接口，当对外展示时则需要屏蔽一些敏感信息，比如身份证号、权限等级等等；</li><li><strong>条件填充</strong>：在不同的情况下可能有些字段要填充，而有些字段不需要填充；</li><li><strong>缓存</strong>：一些数据可能需要缓存，而有一些则不需要，这些数据可能直接缓存在本地，也可能缓存在 DB；</li><li><strong>异步填充</strong>：出于效率考虑，在数据源需要通过频繁的网络 IO 查询时，我们可能会希望异步的完成关联字段填充；</li></ul><p>你所面临的场景越多样化，那么 crane4j 就可能能够带给你越多的便利。</p><h2 id="_4-如何开始使用" tabindex="-1">4.如何开始使用？ <a class="header-anchor" href="#_4-如何开始使用" aria-label="Permalink to &quot;4.如何开始使用？&quot;">​</a></h2><p>如果你是第一次接触此类框架的新用户，那么推荐你先阅读 “<strong>基本概念</strong>” 建立对框架的初步认知，然后跟着 “<strong>快速开始</strong>” 一节尝试在本地编写一个可运行的最小示例，最后再根据情况继续阅读 “<strong>场景示例</strong>” 或其他内容。</p><p>如果你已经使用过类似的框架，你可以直接阅读 “<strong>快速开始</strong>”，然后根据需要阅读后续的 “<strong>场景示例</strong>” 即可。</p>`,24),p=[e];function l(k,r,E,d,g,o){return a(),i("div",null,p)}const F=s(h,[["render",l]]);export{c as __pageData,F as default};
