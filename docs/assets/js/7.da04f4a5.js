(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{274:function(e,r,t){e.exports=t.p+"assets/img/image-20230220150040070.63150c20.png"},289:function(e,r,t){"use strict";t.r(r);var _=t(14),a=Object(_.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[r("img",{attrs:{src:t(274),alt:"image-20230220150040070"}})]),e._v(" "),r("h2",{attrs:{id:"_1-1-1-为什么写"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-1-为什么写"}},[e._v("#")]),e._v(" 1.1.1.为什么写？")]),e._v(" "),r("p",[r("code",[e._v("crane4j")]),e._v(" 的前身是 "),r("a",{attrs:{href:"https://github.com/Createsequence/crane",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("crane")]),r("OutboundLink")],1),e._v("，而 "),r("code",[e._v("crane")]),e._v(" 的前身来自在公司写的一个字段填充框架。当时恰好个人负责的业务有大量重复的字段填充的需求，这些字段跟核心业务无关，就是重复的关联查询，但是又无处不在，实在厌倦了联查和手动塞值的我，抽了点时间在项目里面加了一个基于 "),r("code",[e._v("MybatisPlus")]),e._v(" 自动查询并填充字段值的小插件。")]),e._v(" "),r("p",[e._v("随着时间的推移，这个插件的功能越来越丰富，又支持了枚举和常量转换，接着又是基于切面的自动填充......最后又独立成了一套框架，这就是 crane 的前身，至今仍然在生产环境中发光发热。")]),e._v(" "),r("p",[e._v("去年年前的时候，我抽时间重构了这个框架的代码，并且把它传到了 "),r("code",[e._v("Gitee")]),e._v("，这个项目就是 "),r("a",{attrs:{href:"https://github.com/Createsequence/crane",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("crane")]),r("OutboundLink")],1),e._v("。"),r("code",[e._v("crane")]),e._v(" 更新了大概半年多，功能渐渐稳定，不过早期设计不足导致扩展困难的问题也越来越明显。重新梳理的功能后，我决定基于 "),r("code",[e._v("crane")]),e._v(" 的功能和一些概念再进行一次彻底的重构，于是就有了现在的 "),r("code",[e._v("crane4j")]),e._v("。")]),e._v(" "),r("p",[e._v("相比起前辈 "),r("code",[e._v("crane")]),e._v("，"),r("code",[e._v("crane4j")]),e._v(" 的代码更健壮，设计更合理，功能更强大，使用更灵活。")]),e._v(" "),r("h2",{attrs:{id:"_1-1-2-它解决了什么问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-2-它解决了什么问题"}},[e._v("#")]),e._v(" 1.1.2.它解决了什么问题？")]),e._v(" "),r("p",[e._v("“根据 A 的 key 值拿到 B，再把 B 的属性映射到 A”，这就是 "),r("code",[e._v("crane4j")]),e._v(" 的核心功能。")]),e._v(" "),r("p",[e._v("在面向业务的开发中经常会遇到一些繁琐的数据组装工作，这些工作一般相对核心业务逻辑较为独立，但是由于数据来源五花八门，且填充的字段与类型也不尽相同，导致往往需要编写大量的样板代码处理。")]),e._v(" "),r("p",[r("code",[e._v("crane4j")]),e._v(" 旨在为了解决这种烦恼而生，它允许开发者通过精简的配置与极少的代码，即可从不同数据源中获得不同类型、不同名称的字段并填充到指定的对象里，组件化的设计也允许开发者灵活的植入自定义的逻辑。")]),e._v(" "),r("h2",{attrs:{id:"_1-1-3-它有什么特性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-3-它有什么特性"}},[e._v("#")]),e._v(" 1.1.3.它有什么特性？")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("多样的数据源支持")]),e._v("：支持将枚举、普通键值对缓存，甚至实例方法或静态方法作为数据源，也支持通过简单的自定义扩展兼容更多类型的数据源，并且对所有类型数据源都提供缓存支持；")]),e._v(" "),r("li",[r("strong",[e._v("强大的字段映射能力")]),e._v("：通过注解即可完成不同类型字段之间映射自动转换，支持模板、排序、分组、自动填充嵌套对象等等功能，除 JDK 原生反射外还支持更快的字节码调用；")]),e._v(" "),r("li",[r("strong",[e._v("高度的可扩展性")]),e._v("：所有主要组件均可由用户自由替换，配合 Spring 的依赖注入可实现轻松优雅的完成自定义扩展。")]),e._v(" "),r("li",[r("strong",[e._v("丰富的可选功能")]),e._v("：提供包括方法返回值与方法入参参数的自动填充，多线程填充，自定义符合注解以及表达式等可选功能；")])]),e._v(" "),r("p",[e._v("在后续，将会陆续完成包括 JSON 对象的字段动态填充/替换、基于 redis 的数据源缓存、基于 "),r("s",[e._v("Myabtis/MybatisPlus")]),e._v("（已完成）、JPA 等 ORM 框架的数据源自动适配等新功能。")]),e._v(" "),r("h2",{attrs:{id:"_1-1-4-如何使用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-4-如何使用"}},[e._v("#")]),e._v(" 1.1.4.如何使用？")]),e._v(" "),r("p",[e._v("想要快速体验 "),r("code",[e._v("crane4j")]),e._v("，请阅读快速开始一章，如果想要进一步了解和使用 "),r("code",[e._v("crane4j")]),e._v("，可以按推荐目录顺序阅读文档。")]),e._v(" "),r("p",[e._v("源码中记录每个类都有对应的测试用例，如果仍然感觉不好理解，可以在把源码中的示例模块 "),r("code",[e._v("crane4j-example")]),e._v(" ("),r("a",{attrs:{href:"https://gitee.com/CreateSequence/crane4j/tree/dev/crane4j-example",target:"_blank",rel:"noopener noreferrer"}},[e._v("Gitee"),r("OutboundLink")],1),e._v(" / "),r("a",{attrs:{href:"https://github.com/opengoofy/crane4j/tree/dev/crane4j-example",target:"_blank",rel:"noopener noreferrer"}},[e._v("GitHub"),r("OutboundLink")],1),e._v(")  拉到本地运行一下，里面有针对某些比较复杂的功能的集成测试，或许会有助于理解和使用对应功能。")])])}),[],!1,null,null,null);r.default=a.exports}}]);