## 操作排序

默认情况下，在同一个类中的操作的排序为：

- 在属性上直接使用 `@Assemble` 声明的操作，按属性顺序排序；
- 通过 `@Operations` 声明的操作，按它们声明的顺序排序；
- 在同一类中，属性上声明的操作优先于类上声明的操作；
- 在不同中，子类中声明的操作优先于父类中声明的操作；

除此之外，也可以通过 `@Assemble#sort` 属性或者 spring 的 `@Order` 注解可以指定不同操作之间的顺序：

~~~java
public class Student {
    @Assemble(container = "id", sort = 0, props = @Mapping(ref = "id3"))
    private Integer id1;
    @Order(1)
    @Assemble(container = "id", props = @Mapping(ref = "id4"))
    private Integer id2;
    @Assemble(container = "id", sort = 1, props = @Mapping(ref = "id2"))
    private Integer id3;
    private Integer id4;
}
~~~

上述示例中， 三个操作的顺序分别为 `id1 -> id3 -> id2`， `sort` 的值越小，则排序时越靠前，这个顺序将会优先于默认的排序规则，当同时使用 `sort` 以及 `@Order` 时，将会以 `@Order` 指定的排序值为准。

**按顺序执行**

需要注意的是，**排序值不一定代表最终的执行顺序**，只代表遍历 `BeanOperations` 中的装配操作时的顺序，最终的执行顺序**需要通过 `BeanOperationExecutor` 来保证**。

因此上述例子中的操作并不一定会按顺序执行，如果我们希望操作严格按排序执行，就需要指定执行器为有序执行器 `OrderedBeanOperationExecutor`，比如：

~~~java
public class Student {
    @Assemble(
        container = "id", sort = 0, props = @Mapping(ref = "id3"), 
        handler = OrderedBeanOperationExecutor.class
    )
    private Integer id1;
    
    @Order(1)
    @Assemble(
        container = "id", props = @Mapping(ref = "id4"), 
        handler = OrderedBeanOperationExecutor.class
    )
    private Integer id2;
    
    @Assemble(
        container = "id", sort = 1, props = @Mapping(ref = "id2"), 
        handler = OrderedBeanOperationExecutor.class
    )
    private Integer id3;
    private Integer id4;
}
~~~

有序执行器不过相较其他执行器性能会差一些，用户可以根据自己的需求选择。

:::tip

- 拆卸操作和装配操作都可以排序，不过为了装配操作可以一次性尽可能多像执行器提交待处理对象，因此执行器一般都会先执行完全部拆卸操作后，再执行装配操作。
- 关于执行器，请参阅[操作执行器](./../execute/4.3.操作执行器.md)一节；
- 如果觉得配置繁琐，也可以定义组合注解简化该配置，请参阅[组合注解](./../advance/5.2.组合注解.md)；

:::