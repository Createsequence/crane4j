## 概述

一般情况下，`crane4j` 将在基于 SpringAOP 提供的在切面中自动完成方法入参与返回值填充的操作称为自动填充。

## 4.2.1.声明自动填充

**填充方法返回值**

基于 `SpringAOP`，当我们在方法上添加 `@AutoOperate` 后，切面类 `MethodResultAutoOperateAspect` 即可在方法返回时对返回值进行自动填充：

~~~java
@AutoOperate(type = Foo.class)
public List<Foo> getFooList() {
    // do nothing
}
~~~

返回值类型可以是单个对象、对象数组或对象的 `Collection` 集合。

**自动填充方法参数**

基于 `SpringAOP`，当我们在方法上添加 `@ArgAutoOperate` 后，切面类 `MethodArgumentAutoOperateAspect` 即可在方法执行前对入参进行自动填充：

~~~java
// 1.可以注解在参数上
@ArgAutoOperate
public void getFooList(@AutoOperate(type = Foo.class) Foo foo) {
    // do nothing
}

// 2.可以注解在方法上
@ArgAutoOperate(@AutoOperate(value = "foo", type = Foo.class))
public void getFooList(Foo foo) {
    // do nothing
}
~~~

与返回值填充一样，填充的数据可以是单个对象、对象数组或对象的 `Collection` 集合类型的参数，它支持所有返回值自动填充支持的**全部功能**。

## 4.2.2.包装类提取

有时候我们会将注解添加在 `Controller` 中的方法上，而这些方法的返回值常常会使用通用响应体包装，比如：

~~~java
public class Result<T> {
    private Integer code;
    private T data;
}

@AutoOperate(type = Foo.class)
public Result<List<Foo>> getFooList() {
    // do nothing
}
~~~

上述方法实际上需要填充的对象不是 `Result`，而是 `Result` 中的 `data`。除了把 `Result` 作为填充对象，在 `data` 上添加 `@Disassemble` 注解声明拆卸外，还可以直接通过 `on` 属性提取特定属性值进行填充，比如：

~~~java
@AutoOperate(type = Foo.class, on = "data")
public Result<List<Foo>> getFooList() {
    // do nothing
}
~~~

:::tip

`on` 属性默认支持链式操作符，即支持通过 `xx.xx.xx` 的方式访问内部对象的属性，比如我们常见的 `Result<PageInfo<Foo>>` 就可以通过 `on = data.list` 取得嵌套在 `PageInfo.list` 中的待处理数据。

:::

## 4.2.3.应用条件表达式

通过注解的 `condtion` 可以设置应用条件的表达式，在执行填充前，将会根据表达式的计算结果确定是否要执行这次填充，比如：

~~~java
@AutoOperate(type = Foo.class, condition ="#type != 1 && ${config.enable-fill-foo}")
public List<Foo> getFoo(Integer type) {
    // do nothing
}
~~~

上述示例表示仅当 `入参的 type 不为 1 ，且配置文件中 config.enable-fill-foo 为 true` 时才执行填充。

默认的表达式引擎为 SpEL 表达式，因此可以在里面可以通过 `#result` 引用返回值，并通过 `#参数名` 引用方法入参，返回值可以是 `boolean` 值，或者 `'true'` 或 `'false'` 字符串。

:::tip

在 spring 环境中默认支持 SpEL 表达式，也可以更换表达式引擎支持其他类型的表达式。

:::

## 4.2.4.分组填充

通过注解的 `includes` 或者 `excludes` 属性可以设置本次执行的操作组，比如：

~~~java
@AutoOperate(type = Foo.class, includes = {"base", "foo"},)
public List<Foo> getFoo(Integer type) {
    // do nothing
}
~~~

上述示例中，当进行填充时，仅会完成 `Foo` 中组别带有 `base` 或 `foo` 的装配/拆卸操作。

## 4.2.5.指定执行器

通过注解的 `executor` 可以指定本次填充操作的执行器：

~~~java
@AutoOperate(type = Foo.class, executor = OrderedBeanOperationExecutor.class)
public List<Foo> getFoo(Integer type) {
    // do nothing
}
~~~

不同的执行器将会为操作带来不同的影响，比如上述示例指定的 `OrderedBeanOperationExecutor` 支持按规定的顺序同步的完成填充，而 `AsyncBeanOperationExecutor` 则支持并发填充。

:::tip

关于执行器，请参照[操作执行器](./4.3.操作执行器.md)一节

:::
