## 概述

在 `crane4j` 中，默认情况下，操作的排序按照以下规则进行：

- 直接在属性上使用 `@Assemble` 声明的操作按属性的顺序进行排序；
- 通过 `@Operations` 声明的操作按照它们的声明顺序进行排序；
- 在同一类中，属性上声明的操作优先于类上声明的操作；
- 在不同类中，子类中声明的操作优先于父类中声明的操作；

除了默认排序规则，您还可以使用 `@Assemble` 注解的 `sort` 属性或 Spring 的 `@Order` 注解来指定不同操作之间的顺序。

## 3.6.1.指定排序值

通过 `@Assemble` 注解的 `sort` 属性，或者 Spring 的 `@Order` 注解可以指定操作值，其中：

- 值越小，操作的排序越靠前；
- `@Assemble`注解的`sort`属性优先于Spring的`@Order`注解；
- 当属性上存在多个操作声明时，`@Order`注解适用于所有声明的操作；

例如：

~~~java
public class Student {
    @Assemble(container = "id", sort = 0, props = @Mapping(ref = "id3"))
    private Integer id1;
    @Order(1)
    @Assemble(container = "id", props = @Mapping(ref = "id4")) // 默认排序值为 Integer.MAX_VALUE
    private Integer id2;
    @Assemble(container = "id", sort = 1, props = @Mapping(ref = "id2"))
    private Integer id3;
    private Integer id4;
}
~~~

在上述示例中，根据排序值， `Student` 类中的三个操作的顺序为 `id1 -> id3 -> id2`。

## 3.6.2.按顺序执行

需要注意的是，**排序值并不一定代表最终的执行顺序**，它只代表在遍历 `BeanOperations` 中的装配操作时的顺序。最终的执行顺序需要通过 `BeanOperationExecutor` 来保证。

如果您希望操作按照严格的排序执行，比如想要实现**级联装配**的效果，可以指定执行器为有序执行器 `OrderedBeanOperationExecutor` 。

比如：

~~~java
public class Student {
    @Assemble(container = "student", sort = 0, props = @Mapping(ref = "id3"))
    private Integer id1;

    @Order(1)
    @Assemble(container = "student", props = @Mapping(ref = "id4"))
    private Integer id2;

    @Assemble(container = "student", sort = 1, props = @Mapping(ref = "id2"))
    private Integer id3;
    private Integer id4;
}
~~~

需要注意的是，有序执行器相对于其他执行器可能会在数据源获取方面产生**额外的性能消耗**。

在上述示例中，使用有序执行器将会对 `student` 进行三次访问，而使用无序执行器则只需要一次请求。因此，在选择执行器时，您需要权衡性能和执行顺序的需求，选择最适合您的场景的执行器。

:::tip

- 拆卸操作和装配操作都可以进行排序。然而，为了使装配操作可以一次性尽可能多地提交待处理对象给执行器，一般情况下执行器会先执行所有的拆卸操作，然后再执行装配操作。这样可以提高执行效率和性能；
- 关于执行器，请参阅[操作执行器](./../execute/4.3.操作执行器.md)一节；

:::