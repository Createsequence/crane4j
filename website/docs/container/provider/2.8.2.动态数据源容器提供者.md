## 动态数据源容器提供者

**使用**

动态数据源容器提供者 `DynamicSourceContainerProvider` 是一个在特定上下文中可以切换容器数据源的容器提供者。

当容器创建时，会在上下文中维护一个 `Map` 集合，里面根据 `namespace` 存放了容器的数据源，当从它那获得的数据源容器被调用时，将会动态的从该 `Map` 集合中的数据源中获取数据源。由此，通过修改提供者在当前线程中的容器数据源，我们可以让数据源容器返回不同的数据。

比如：

~~~java
// 获取容器
DynamicSourceContainerProvider provider = new SharedContextContainerProvider();
Container<Integer> container = provider.getContainer("test");

// 不设置数据源时默认返回空的 Map 集合
container.get(Collections.emptyList()); // = []

// 设置数据源，固定返回某个值
Map<Integer, Object> map = new HashMap<Integer, Object>(){{ put(1, "one"); put(2, "two"); put(3, "three"); }};
DataProvider<Integer, Object> dataProvider = DataProvider.fixed(map);
provider.setDataProvider("test", dataProvider);
container.get(Collections.emptyList()); // = [{1="one"}, {2="two"}, {3="three"}]

// 设置数据源，根据 id 返回值
provider.setDataProvider("test", ids -> ids.stream().collect(Collectors.toMap(Function.identity(), ids -> "name" + id)));
container.get(Arrays.asList(1, 2, 3)); // = [{1="name1"}, {2="name2"}, {3="name3"}]

// 移除数据源
provider.remove("test"); // 移除当前线程上下文中，namespace 为 test 的容器的数据源
provider.clear(); // 移除当前线程上下文中，所有容器的数据源
~~~

**选择下文实现**

`DynamicSourceContainerProvider` 是一个顶层接口，它根据存放数据源的上下文类型分为两种实现：

- 共享上下文：实现类为 `SharedContextContainerProvider` ，不同线程间共享一个上下文，通过读写锁保证线程安全；
- 线程上下文：实现类为 `ThreadContextContainerProvider ` ，不同线程间使用 `ThreadLocal` 隔离；

这两者的区别本质上就是数据源容器用于根据命名空间获取数据源的 `Map` 集合要从哪里取，用户根据自己的情况选择即可。

:::warning

当选择线程上下文模式时，在使用异步执行器 `AsyncBeanOperationExecutor` 或者通过其他方式异步的执行操作的时候需要格外注意。

:::
