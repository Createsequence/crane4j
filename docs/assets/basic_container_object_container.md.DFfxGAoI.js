import{_ as s,c as i,o as a,a4 as n}from"./chunks/framework.CTZgbW0d.js";const g=JSON.parse('{"title":"对象容器","description":"","frontmatter":{},"headers":[],"relativePath":"basic/container/object_container.md","filePath":"basic/container/object_container.md","lastUpdated":1708662365000}'),t={name:"basic/container/object_container.md"},e=n(`<h1 id="对象容器" tabindex="-1">对象容器 <a class="header-anchor" href="#对象容器" aria-label="Permalink to &quot;对象容器&quot;">​</a></h1><p>在默认情况下，<code>Container</code> 总是用于根据指定的 key 值查询对应的数据源，但是在有些情况下，我们可能需要同时<strong>根据多个 key 值，或一些复杂的自定义条件</strong>确认要从数据源中获取哪些数据，并如何对 key 对应。</p><p>为此，在配置填充操作时，你可以<strong>不指定 key 值</strong>，此时，crane4j 会直接将待填充的对象作为 key 值传入容器，由用户自行决定要如何返回数据源，此类容器称为“<strong>对象容器</strong>”。</p><p>比如，我们现有待填充对象 <code>Foo</code>，我们需要同时根据 <code>Foo</code> 的 <code>id</code> 和 <code>code</code> 去确认一个对应的数据。</p><p>因此，我们在类上添加 <code>@Assemble</code> 注解，但是不指定任何的 key 值：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Assemble</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">container</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;foo_info&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">props</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Mapping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ref</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 直接以当前的 Foo 对象作为 key，去数据源容器中查询</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Data</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Integer id;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String code;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String name;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>此时，我们声明一个容器，该容器<strong>入参为待填充的 <code>Foo</code> 集合本身，并返回按 <code>Foo</code> 对象分组的数据集</strong>：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Container&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; objectContainer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Containers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forLambda</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;foo_info&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, fooList </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fooList.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">collect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Collectors.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    	foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo, foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;#&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getCode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p><code>Container</code> 返回的数据必须按<strong>入参的对象实例本身</strong>分组，如果重写了 <code>equals</code> 或者 <code>hashCode</code> 需要格外注意。</p></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>如果你的目的仅仅是为了对目标对象做一些处理，而不是真的需要以目标对象本身为数据源进行填充，那么你可以直接让目标类实现 <code>OperationAwareBean</code> 或 <code>SmartOperationAwareBean</code> 接口，在回调方法中实现你想要的效果。</p><p>具体可以参见 <a href="./../../advanced/callback_of_component.html">组件的回调接口</a> 一节中的 “对象的回调接口” 这一小节。</p></div>`,10),h=[e];function p(k,l,o,d,r,E){return a(),i("div",null,h)}const y=s(t,[["render",p]]);export{g as __pageData,y as default};
