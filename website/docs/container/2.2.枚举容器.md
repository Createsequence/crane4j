## 2.2.1.基本使用

我们可以通过 `ConstantContainer.forEnum` 方法基于枚举类快速的配置一个枚举数据源：

~~~java
@Getter
@RequiredArgsConstructor
private enum Num {
    ONE(1, "one"),
    TWO(2, "two");
    private final int code;
    private final String value;
}

// 使用 ConstantContainer.forEnum 方法构建容器
// 容器缓存的数据为： {1 = ONE}, {2 = TWO}
Container<String> container = ConstantContainer.forEnum("num", FooEnum.class, Enum::getCode); // 指定 key 值为 code
~~~

使用后通过 key 值即可从容器中获得 code 对应的 `Enum` 实例。

## 2.2.2.可选注解

除普通枚举外，我们也可以通过 `@ContainerEnum` 注解来进一步定义容器的具体信息：

~~~java
@ContainerEnum(namespace = "AnnotatedEnum", key = "key", value = "value")
@Getter
@RequiredArgsConstructor
private enum Num {
    ONE(1, "one"),
    TWO(2, "two");
    private final int key;
    private final String value;
}

// 使用 ConstantContainer.forEnum 方法构建容器
// 容器缓存的数据为： {1 = "one"}, {2 = "two"}
Container<String> container = ConstantContainer.forAnnotatedEnum(DefaultAnnotatedEnum.class, new SimpleAnnotationFinder()); 
~~~

在这里，我们通过 `@ContainerEnum` 注解配置了一些额外的信息：

- `namespace`：命名空间为 `AnnotatedEnum`，若不配置则默认为枚举类的 `Class.getSimpleName()`；
- `key`：数据源对象的 `key` 值取枚举项的 `key` 字段值，若不配置则默认为枚举的 `Enum.name()`；
- `value`：数据源对象为枚举项的 `value` 字段值，若不配置则默认为枚举项本身；

## 2.2.3.自动扫描

此外，基于常量类的数据源可以手动配置，也可以在配置文件中配置扫描路径：

~~~yml
crane4j:
 # 扫描指定包路径，将该路径下被注解的枚举适配并注册为数据源容器
 container-enum-packages: cn.createsequence.crane4j.springboot.config.*
 # 是否只加载被ContainerEnum注解的枚举
 only-load-annotated-enum: true
~~~

上述路径下被扫描到的枚举类将会被适配为数据源容器，并自动注册。

:::tip

枚举数据源只是基于枚举构建的数据源，它的返回的数据源对象未必要是枚举项本身， 这就是 `@ContainerEnum` 的作用。

:::

