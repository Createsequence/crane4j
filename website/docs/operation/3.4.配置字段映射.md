## 概述

<img src="https://img.xiajibagao.top/image-20230220182129822.png" alt="image-20230220182129822" style="zoom: 50%;" />

字段映射是装配操作的一部分，用于描述将数据源对象的哪些字段的值会填充到目标对象哪些字段上。

## 3.2.1.映射属性

字段映射配置的用法有点像 `MapStruct` ，在当我们通过 `@Assemble` 注解声明一个装配操作时，我们可以在 `props` 中配置字段映射：

~~~java
public class StudentVO {
    @Assemble(
        container = "student", props = {
            @Mapping(src = "studentName", ref = "name"), // student.studentName -> studentVO.name
            @Mapping(src = "studentClassName", ref = "className") // student.studentClassName -> studentVO.className
        }
    )
    private Integer id;
    private String name;
    private String className;
}
~~~

上述示例表示将根据 `id` 查出 `Student` 对象后，将：

- `Student.studentName` 映射到 `StudentVO.name`；
- `Student.studentClassName` 映射到 `StudentVO.className`；

数据源对象可以是 `Map` 集合，此时 `src` 即为要获取的键值的 `key`，如果是对象（包括枚举）则为要获取的属性值的名称。

**映射同名属性**

此外，如果 `src` 和 `ref` 指定的字段名称相同，则可以直接在 `value` 中同时指定，比如：

~~~java
public class StudentVO {
    @Assemble(
        container = "student", 
        props = @Mapping("name") // student.name -> studentVO.name
    )
    private Integer id;
    private String name;
}
~~~

:::tip

字段映射实际上基于反射工厂类 `PropertyOperator` 完成，不过默认提供 JDK 原生的反射和基于 `ReflectAsm` 的字节码反射两种实现，它们都支持一定程度的自动类型转换。

:::

## 3.2.2.映射对象

当在 `@Mapping` 注解不指定源字段 `src` 时，表示直接将整个数据源对象作为映射值：

~~~java
public class StudentVO {
    @Assemble(
        container = "student", 
        props = @Mapping(ref = "student") // student -> studentVO.student
    )
    private Integer id;
    private Student student;
}
~~~

上述示例表示将根据 `id` 查出 `Student` 对象后，直接将 `Student` 对象塞入 `StudentVO.student` 字段中。

一般该配置适合用于在组装对象，或者数据源本身就是某个字典值或者枚举值的情况。

## 3.2.3.映射 key 字段

当在 `@Mapping` 注解不指定引用字段 `ref` 时，表示直接将映射值映射到 `key` 字段上：

~~~java
public class StudentVO {
    @Assemble(
        container = "gender", 
        props = @Mapping(src = "name")  // gender.name -> studentVO.sex
    )
    private String sex;
}
~~~

上述示例表示将根据 `StudentVO.sex` 查出性别字典对象 `Gender` 后，将中对应的 `Gender.name` 在映射会 `StudentVO.sex` 字段。

## 3.2.4.批量映射

通过切换装配处理器，我们可以完成一对多或者多对多的装配操作。在这种情况下，待处理对象只有一个，而对应的数据源对象有多个，则我们使用 `@Mapping` 配置的字段映射将变为批量映射，即先从集合中的每一个数据源对象获取 `src` 指向的属性值，然后再将所有的属性值组装为集合，再赋给 `ref` 指向的目标对象中的属性。

比如：

~~~java
public class StudentVO {
    @Assemble(
        container = "teacher", 
        props = @Mapping(src = "name", ref = "teacherNames") // [teacher, teacher...] -> [teacher.name, teacher.name...] -> studentVO.teacherNames
        handler = ManyToManyAssembleOperationHandler.class
    )
    private String teacherIds; // i d字符串，比如：1, 2, 3
    private List<String> teacherNames;
}
~~~

上述示例表示，根据 `teacherIds` 字段字符串中通过分隔符分割的多个 `key` 值，查出关联的多个 `Teacher` 对象，然后将 `Teacher` 集合映射为 `Teacher.name` 集合并塞入 `StudentVO.teacherNames` 字段中。

该字段映射同样**遵循普通字段映射的语义**，比如对象映射：

~~~java
public class StudentVO {
    @Assemble(
        container = "teacher", 
        props = @Mapping(ref = "teachers")
        handler = ManyToManyAssembleOperationHandler.class
    )
    private String teacherIds; // 格式默认支持 1, 2, 3 格式
    private List<Teacher> teachers;
}
~~~

在批量映射的情况下，返回的对象都将会是**数据源对象或数据源对象的属性集合**。

::: warning

- 需要注意的是，当用户的传入的 `id1, id2, id3...` 这样的字符串时，分割后的值将保持为 `String` 类型，用户需要自己确保容器支持接受 `String` 类型的 `key`；
- 若果分隔符不为 `，`，或者有其他拆分规则，可以为 `ManyToManyAssembleOperationHandler` 设置自己需要的字符串分割器；

:::

## 3.2.5.映射模板

为了保持代码的整洁，我们可以将字段映射配置抽离为独立的模板。

比如，现有字段配置如下：

~~~java
public class StudentVO {
    @Assemble(
        container = "student", 
        props = {
            @Mapping(src = "studentName", ref = "name"),
            @Mapping(src = "studentClassName", ref = "className"),
            @Mapping(src = "studentTeacherName", ref = "teacherName")
        }
    )
    private Integer id;
    private String name;
    private String className;
    private String teacherName;
}
~~~

我们创建一个模板类 `StudentMappingTemplate`，并将 `props` 中的映射配置通过 `@MappingTemplate` 移至模板类：

~~~java
@MappingTemplate({
    @Mapping(src = "studentName", ref = "name"),
    @Mapping(src = "studentClassName", ref = "className"),
    @Mapping(src = "studentTeacherName", ref = "teacherName")
})
private static class StudentMappingTemplate {}
~~~

然后再在 `@Assemble` 通过 `propTemplates` 引入模板即可：

~~~java
public class StudentVO {
    @Assemble(
        container = "student",
        props = @Mapping(src = "studentTeacherAge", ref = "teacherAge"),
        propTemplates = StudentMappingTemplate.class
    )
    private Integer id;
    private String name;
    private String className;
    private String teacherName;
    private Integer teacherAge;
}
~~~

通过模板引入的字段映射配置与通过 `@Assemble.props` 声明的配置效果一致，并且两者可以同时存在。

上述配置的字段映射规则，按就近原则执行。即离 `StudentVO` 越近，且排序越靠前的字段优先完成映射，后映射的字段会覆盖已有的值。