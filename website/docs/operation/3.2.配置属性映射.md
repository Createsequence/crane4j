## 概述

属性/字段映射是装配操作的一部分，用于描述将数据源对象的哪些字段的值填充到目标对象的哪些字段上。

在装配操作中，我们可以使用 `@Mapping` 注解来配置字段映射，以指定要进行映射的属性和对应关系。`@Mapping` 注解包含以下信息：

- `src` 属性：指定要从数据源对象中获取值的属性名。
- `ref` 属性：指定要填充值的目标属性名。

通过在目标对象的字段上添加 `@Mapping` 注解，并设置对应的 `src `和 `ref` 属性，我们告知装配操作处理器哪些属性需要进行映射以及属性之间的对应关系，不通的 `src` 和 `ref` 搭配将会产生不同的效果。

<img src="https://img.xiajibagao.top/image-20230220182129822.png" alt="image-20230220182129822" style="zoom: 50%;" />

## 3.2.1.将属性映射到属性

字段映射配置类似于 MapStruct，在使用 `@Assemble` 注解声明装配操作时，我们可以在 `props` 中属性使用 `@Mapping` 注解配置属性映射。

例如：

```java
public class StudentVO {
    @Assemble(
        container = "student", props = {
            @Mapping(src = "studentName", ref = "name"), // student.studentName -> studentVO.name
            @Mapping(src = "studentClassName", ref = "className") // student.studentClassName -> studentVO.className
        }
    )
    private Integer id;
    private String name;
    private String className;
}
```

上述示例中，我们通过`@Assemble`注解指定了数据源容器和字段映射。其中，`props` 属性中使用了 `@Mapping` 注解配置了两个映射属性，分别将`Student.studentName`映射到`StudentVO.name`，将`Student.studentClassName`映射到`StudentVO.className`。

**同名属性**

另外，如果 `src` 和 `ref` 指定的字段名称相同，可以直接在`value`中同时指定。例如：

```java
public class StudentVO {
    @Assemble(
        container = "student", 
        props = @Mapping("name") // student.name -> studentVO.name
    )
    private Integer id;
    private String name;
}
```

**特殊对象支持**

数据源对象可以是 `Map` 集合，此时 `src` 即为要获取的键值的 `key`，而如果是对象（包括枚举）则为要获取的属性值的名称，这种情况下用户需要确保对应的属性存在 `setter` 和 `getter` 方法。

**自动类型转换**

字段映射的实现基于反射工厂 `PropertyOperator` 实现，默认使用的实现类支持一定程度的自动类型转换，具体参见 `ConverterManager`。

## 3.2.2.将对象映射到属性

当在 `@Mapping` 注解中不指定源字段 `src` 时，表示直接将整个数据源对象作为映射值。

例如：

```java
public class StudentVO {
    @Assemble(
        container = "student", 
        props = @Mapping(ref = "student") // student -> studentVO.student
    )
    private Integer id;
    private Student student;
}
```

上述示例中，根据 `id` 查找到 `Student` 对象后，直接将该 `Student` 对象赋值给`StudentVO.student` 字段。

这种配置通常适用于对象的组装，或者当数据源对象本身就是某个字典值或枚举值的情况。

## 3.2.3.将值映射到键属性

当在 `@Mapping` 注解中不指定引用字段 `ref` 时，表示直接将映射值映射到 `key` 字段上。

例如：

```java
public class StudentVO {
    @Assemble(
        container = "gender", 
        props = @Mapping(src = "name")  // gender.name -> studentVO.sex
    )
    private String sex;
}
```

上述示例中，根据 `StudentVO.sex` 查找到性别字典对象 `Gender` 后，将其对应的 `Gender.name` 映射回 `StudentVO.sex` 字段。

这种配置适用于将字典值或枚举值映射回目标对象的字段上。

## 3.2.4.批量映射

在一些情况下下，从数据源容器获得的一个键值将对应一批数据源对象（比如一对多或者多对多装配）。在这种情况下，字段映射将变为**批量映射**模式

具体而言，对于集合或数组中的每个数据源对象，我们会从中获取指定的  `src`  属性值，并将所有属性值组装为集合，然后将该集合赋值给目标对象中的  `ref`  属性。

例如：

```java
public class StudentVO {
    @Assemble(
        container = "teacher",
        handler = "manyToManyAssembleOperationHandler",
        // [teacher, teacher...] -> [teacher.name, teacher.name...] -> studentVO.teacherNames
        props = @Mapping(src = "name", ref = "teacherNames") 
    )
    private String teacherIds; // 以逗号分隔的字符串，例如：1, 2, 3
    private List<String> teacherNames;
}
```

上述示例中，根据 `teacherIds` 字段字符串中通过逗号分隔的多个键值，查询关联的多个 `Teacher` 对象，然后将 `Teacher` 对象集合的 `name` 属性映射为 `List<String>` 并赋值给 `StudentVO.teacherNames` 字段。

该字段映射遵循普通字段映射的语义，例如对象映射：

```java
public class StudentVO {
    @Assemble(
        container = "teacher", 
        handler = "manyToManyAssembleOperationHandler",
        props = @Mapping(ref = "teachers")
    )
    private List<Integer> teacherIds; // 也可以直接是集合或者数组
    private List<Teacher> teachers;
}
```

在批量映射的情况下，返回的对象可以是数据源对象或数据源对象的属性集合。

:::warning

- 如果用户传入的字符串是 `id1, id2, id3...` 这样的格式，分割后的值默认保持为 `String` 类型。用户需要确保目标容器能够接受 `String` 类型的键；
- 如果分隔符不是逗号 `,`，或者有其他拆分规则，用户可以为 `ManyToManyAssembleOperationHandler` 设置自定义的字符串分割器；

:::

## 3.2.5.映射模板

为了保持代码的整洁性，我们可以将字段映射配置抽取为独立的模板。

例如，给定以下字段配置：

```java
public class StudentVO {
    @Assemble(
        container = "student", 
        props = {
            @Mapping(src = "studentName", ref = "name"),
            @Mapping(src = "studentClassName", ref = "className"),
            @Mapping(src = "studentTeacherName", ref = "teacherName")
        }
    )
    private Integer id;
    private String name;
    private String className;
    private String teacherName;
}
```

我们可以创建一个模板类 `StudentMappingTemplate`，将 `props` 中的映射配置移到模板类中：

```java
@MappingTemplate({
    @Mapping(src = "studentName", ref = "name"),
    @Mapping(src = "studentClassName", ref = "className"),
    @Mapping(src = "studentTeacherName", ref = "teacherName")
})
private static class StudentMappingTemplate {}
```

然后，在 `@Assemble` 注解中使用 `propTemplates` 引入模板：

```java
public class StudentVO {
    @Assemble(
        container = "student",
        props = @Mapping(src = "studentTeacherAge", ref = "teacherAge"),
        propTemplates = StudentMappingTemplate.class
    )
    private Integer id;
    private String name;
    private String className;
    private String teacherName;
    private Integer teacherAge;
}
```

通过模板引入的字段映射配置与通过 `@Assemble.props` 声明的配置效果相同，并且两者可以同时存在。

字段映射规则按照就近原则执行。即离 `StudentVO` 越近，且排序靠前的字段优先完成映射，后面的映射字段会覆盖已有的值。

## 3.2.6.链式操作符

`crane4j` 支持在 `@Mapping` 注解中，通过类似 js 的链式操作符的方式来访问及设置嵌套对象的属性。

例如，我们有一个 `Foo` 类如下：

```java
public class FooVO {
    @Assemble(container = "foo", props = @Mapping(src = "name", ref = "nested.name"))
    private Integer id;
    private NestedFoo nested;
}

public class NestedFoo {
    private String name;
}

public class Foo {
    private Integer id;
    private String name;
}
```

我们声明了一个装配操作，假设 `foo` 容器返回的数据源对象是 `Foo`，则上述示例表示，获取到 `Foo` 对象后，将 `Foo.name` 映射到 `FooVO` 对象中 `nested` 属性中的嵌套对象 `NestedFoo` 的 `name` 属性。

除了属性映射外，该功能理论上适用于**所有具备属性访问功能的配置项**，包括但不限于：

- 类级别的配置注解，例如 `@Assemble` 注解的 `key` 属性；
- 自动填充注解 `@AutoOperate` 中的 `on` 属性；
- 方法数据源容器配置中对方法调用结果进行分组的 `key` 字段，例如 `@ContainerMethod` 注解的 `resultKey` 属性；

:::tip

该功能是通过 `ChainAccessiblePropertyOperator` 类实现的。如果用户替换了默认的 `PropertyOperator`，则需要手动使用 `ChainAccessiblePropertyOperator` 对用户的实现进行包装。

:::