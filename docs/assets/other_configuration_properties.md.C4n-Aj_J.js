import{_ as a,c as s,o as i,a4 as e}from"./chunks/framework.4aTu-Nia.js";const E=JSON.parse('{"title":"配置文件","description":"","frontmatter":{},"headers":[],"relativePath":"other/configuration_properties.md","filePath":"other/configuration_properties.md","lastUpdated":1712503124000}'),n={name:"other/configuration_properties.md"},t=e(`<h1 id="配置文件" tabindex="-1">配置文件 <a class="header-anchor" href="#配置文件" aria-label="Permalink to &quot;配置文件&quot;">​</a></h1><p>在 Spring 环境中，你可以基于配置文件对 crane4j 的一些可选项进行配置。</p><h2 id="_1-反射" tabindex="-1">1.反射 <a class="header-anchor" href="#_1-反射" aria-label="Permalink to &quot;1.反射&quot;">​</a></h2><h3 id="_1-1-是否启用字节码反射" tabindex="-1">1.1.是否启用字节码反射 <a class="header-anchor" href="#_1-1-是否启用字节码反射" aria-label="Permalink to &quot;1.1.是否启用字节码反射&quot;">​</a></h3><p><code>crane4j</code> 通过默认引入了基于字节码的反射增强库 <a href="https://github.com/EsotericSoftware/reflectasm" target="_blank" rel="noreferrer">ReflectAsm</a> ，用户可以通过 <code>enable-asm-reflect</code> 开启反射增强功能：</p><div class="language-yml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yml</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">crane4j</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 启用字节码增强</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;"> enable-asm-reflect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span></code></pre></div><p>默认为 <code>false</code>，开启后可以一定程度上提升字段映射的性能，不过对应的可能会带来额外的内存消耗。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>由于兼容性问题，该配置只在 java8 的版本有效。</p></div><h3 id="_1-2-是否支持处理map对象" tabindex="-1">1.2.是否支持处理Map对象 <a class="header-anchor" href="#_1-2-是否支持处理map对象" aria-label="Permalink to &quot;1.2.是否支持处理Map对象&quot;">​</a></h3><p>是否支持对 <code>Map</code> 对象进行属性映射，默认为 <code>true</code>：</p><div class="language-yml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yml</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">crane4j</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;"> enable-map-operate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span></code></pre></div><p>如果你的项目里面没有通过 <code>crane4j</code> 直接处理 <code>Map</code> 或者<code>JSONObject</code> 的需求，可以关闭它。</p><h3 id="_1-3-是否支持链式操作符" tabindex="-1">1.3.是否支持链式操作符 <a class="header-anchor" href="#_1-3-是否支持链式操作符" aria-label="Permalink to &quot;1.3.是否支持链式操作符&quot;">​</a></h3><p>是否支持 <code>xx.xx.xx</code> 这样的链式操作符，默认为 <code>true</code>：</p><div class="language-yml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yml</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">crane4j</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;"> enable-chain-operate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span></code></pre></div><h2 id="_2-容器" tabindex="-1">2.容器 <a class="header-anchor" href="#_2-容器" aria-label="Permalink to &quot;2.容器&quot;">​</a></h2><h3 id="_2-1-扫描常量容器" tabindex="-1">2.1.扫描常量容器 <a class="header-anchor" href="#_2-1-扫描常量容器" aria-label="Permalink to &quot;2.1.扫描常量容器&quot;">​</a></h3><p><code>crane4j</code> 支持将常量类也作为数据源适配为容器，因此提供了 <code>container-enum-packages</code> 配置，用于扫描一个或多个包路径下的枚举，在应用启动后自动注册为容器：</p><div class="language-yml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yml</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">crane4j</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 扫描常量包路径</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;"> container-constant-packages</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">cn.demo.constant.*</span></span></code></pre></div><p>关于容器部分，参见<a href="./../basic/container/constant_container.html">常量容器</a>一节。</p><h3 id="_2-2-扫描枚举容器" tabindex="-1">2.2.扫描枚举容器 <a class="header-anchor" href="#_2-2-扫描枚举容器" aria-label="Permalink to &quot;2.2.扫描枚举容器&quot;">​</a></h3><p><code>crane4j</code> 支持将枚举也作为数据源适配为容器，因此提供了 <code>container-enum-packages</code> 配置，用于扫描一个或多个包路径下的枚举，在应用启动后自动注册为容器：</p><div class="language-yml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yml</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">crane4j</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 扫描枚举包路径</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;"> container-enum-packages</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">cn.demo.constant.enums.*</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 是否只加载被@ContainerEnum注解的枚举</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;"> only-load-annotated-enum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span></code></pre></div><p>关于容器部分，参见<a href="./../basic/container/enum_container.html">枚举容器</a>一节。</p><h3 id="_2-3-扫描方法容器" tabindex="-1">2.3.扫描方法容器 <a class="header-anchor" href="#_2-3-扫描方法容器" aria-label="Permalink to &quot;2.3.扫描方法容器&quot;">​</a></h3><p><code>crane4j</code> 支持将被 Spring 管理的 <code>bean</code> 中带有 <code>@ContainerMethod</code> 方法也适配为容器：</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">crane4j</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;"> enable-method-container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span></code></pre></div><p>默认为 <code>true</code>。</p><h3 id="_2-4-容器缓存配置" tabindex="-1">2.4.容器缓存配置 <a class="header-anchor" href="#_2-4-容器缓存配置" aria-label="Permalink to &quot;2.4.容器缓存配置&quot;">​</a></h3><p>用户可以通过 <code>cache-containers</code> 配置为指定的数据源容器添加缓存功能：</p><div class="language-yml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yml</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">crane4j</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 声明哪些数据源需要包装为缓存</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;"> cache-containers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  shared-cache</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">testContainer</span></span></code></pre></div><p>上述示例表示，在项目启动后，通过 <code>CacheManager</code> 为命名空间为 <code>testContainer</code> 的容器挂载缓存空间 <code>shared-cache</code>。</p><h2 id="_3-自动填充" tabindex="-1">3.自动填充 <a class="header-anchor" href="#_3-自动填充" aria-label="Permalink to &quot;3.自动填充&quot;">​</a></h2><p><code>crane4j</code> 默认支持自动方法返回值与方法入参，用户也可以通过配置自定义是否关闭该功能：</p><div class="language-yml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yml</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">crane4j</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 是否启用参数自动填充</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;"> enable-method-argument-auto-operate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 是否启用返回值自动填充</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;"> enable-method-result-auto-operate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span></span></code></pre></div><p>关于自动填充，参见 <a href="./../basic/trigger_operation.html">触发填充操作</a> 一节。</p><h2 id="_4-操作配置预解析" tabindex="-1">4.操作配置预解析 <a class="header-anchor" href="#_4-操作配置预解析" aria-label="Permalink to &quot;4.操作配置预解析&quot;">​</a></h2><p>由于操作配置对象 <code>BeanOperation</code> 皆由对应的 <code>Class</code> 解析而来，因此若解析器具备缓存功能，可以通过 <code>operate-entity-packages</code> 配置实体类包路径，在执行器进行预解析，从而在后续调用时略过配置解析步骤，加快执行速度：</p><div class="language-yml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yml</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">crane4j</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 操作配置预解析</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;"> operate-entity-packages</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">cn.crane4j.springboot.config.*</span></span></code></pre></div><h2 id="_5-是否忽略-key-值为-null-的操作" tabindex="-1">5.是否忽略 key 值为 null 的操作 <a class="header-anchor" href="#_5-是否忽略-key-值为-null-的操作" aria-label="Permalink to &quot;5.是否忽略 key 值为 null 的操作&quot;">​</a></h2><p>在默认情况下，即使 key 值为 null，crane4j 依然认为其为有效值，并尝试通过容器获取对应的数据。</p><p>举个例子，你定义了一个根据 id 查询用户信息并填充数据的操作，但是当 id 为 null，时 crane4j 依然会拿着 null 去调用查询用户信息的方法。</p><p>在 2.5.0 即以上版本，如果你认为 null 值都是无效值，当 key 值为 null 时需要忽略这个操作，那么可以配置：</p><div class="language-yml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yml</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">crane4j</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 当 key 值为 null 时忽略此操作</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;"> ignore-null-key-when-assembling</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span></code></pre></div><p>该值默认为 true。</p>`,45),l=[t];function p(h,c,r,o,d,k){return i(),s("div",null,l)}const u=a(n,[["render",p]]);export{E as __pageData,u as default};
