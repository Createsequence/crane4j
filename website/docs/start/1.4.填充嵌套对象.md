在前文，我们了解了如何简单的配置数据源并完成填充操作。不过在实际场景中，可能会出现需要填充嵌套对象的复杂情况。

在 cranej4 中，由于针对此类情况，需要先将嵌套对象从目标对象中拆开并平铺后再填充，因此这一步又称为**拆卸操作（Disassemble）**。

**因此，当我们需要填充嵌套对象时，就需要对带有嵌套对象的字段声明一个拆卸操作。**

比如，在 `Foo` 中存在字段 `NestedFoo`，它的对应一个同样需要填充的嵌套对象 `NestedFoo`，此时，我们可以在需要嵌套填充的字段上添加 `@Disassemble` 注解，表明该字段对应的对象也需要进行填充：

~~~java
@ToString
@RequiredArgsConstructor // 使用 lombk 生成构造器
public class Foo {
    @Assemble(container = "number", props = @Mapping(ref = "numName"))
    private final Integer num;
    private String numName;
    
    @Disassemble(NestedFoo.class) // 指定该字段需要进行嵌套填充，类型为 NestedFoo
    private final NestedFoo nestedFoo;
}

@ToString
@RequiredArgsConstructor // 使用 lombk 生成构造器
public class NestedFoo {
    @Assemble(container = "number", props = @Mapping(ref = "name"))
    private final Integer num;
    private String name;
}
~~~

在配置后，当填充 `Foo` 时， crane4j 会一并填充其内部的嵌套对象 `NestedFoo`：

~~~java
Foo foo = new Foo(1, new NestedFoo(2));
operateTemplate.execute(foo);
System.out.println(foo);
// Foo(num=1, numName="one", nestedFoo=NestedFoo(num=2, name="two"))
~~~

同样，若嵌套填充的字段是泛型或者 Object，也可以不指定类型，让 cranej4 进行自动推断：

~~~java
@ToString
@RequiredArgsConstructor // 使用 lombk 生成构造器
public class Foo<T> {
    @Assemble(container = "number", props = @Mapping(ref = "numName"))
    private final Integer num;
    private String numName;
    
    @Disassemble // 不指定类型，等到实际填充的时候再动态推断
    private final T nestedFoo;
}
~~~

:::tip

上述操作很像我们在 Spring 中使用 Validation 进行递归校验，它也是通过在指定的字段上添加 `@Valid` 注解。

:::

:::tip

具体内容，请参见后文“操作配置-拆卸嵌套对象”。

:::