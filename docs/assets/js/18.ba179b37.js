(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{295:function(_,e,v){"use strict";v.r(e);var t=v(14),a=Object(t.a)({},(function(){var _=this,e=_._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h2",{attrs:{id:"_1、填充不生效"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、填充不生效"}},[_._v("#")]),_._v(" 1、填充不生效？")]),_._v(" "),e("ul",[e("li",[_._v("确认 "),e("code",[_._v("@AssembleXXX")]),_._v(" 注解正确配置了 "),e("code",[_._v("container")]),_._v(" 与 "),e("code",[_._v("prop")]),_._v(" 属性；")]),_._v(" "),e("li",[_._v("确认操作涉及的属性存在，且都有相应的 "),e("code",[_._v("setter")]),_._v(" 和 "),e("code",[_._v("getter")]),_._v(" 方法；")]),_._v(" "),e("li",[_._v("确认目标对象对应的 key 属性值不为空；")]),_._v(" "),e("li",[_._v("确认指定的数据源容器确实有根据 key 值列表返回非空集合；")]),_._v(" "),e("li",[_._v("确认通过 "),e("code",[_._v("BeanOperationParser")]),_._v(" 解析类后，得到的 "),e("code",[_._v("BeanOperations")]),_._v(" 中的 "),e("code",[_._v("AssembleOperation")]),_._v(" 列表中有该 key 属性对应的操作配置；")])]),_._v(" "),e("p",[_._v("仍然不行可以在 issues 中或者相关交流群中反馈。")]),_._v(" "),e("h2",{attrs:{id:"_2、如何实现嵌套填充"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、如何实现嵌套填充"}},[_._v("#")]),_._v(" 2、如何实现嵌套填充？")]),_._v(" "),e("p",[_._v("在需要嵌套填充的属性上添加 "),e("code",[_._v("@Disassemble")]),_._v(" 注解即可，具体参见 "),e("RouterLink",{attrs:{to:"/operation/3.4.拆卸嵌套对象.html"}},[_._v("拆卸嵌套对象")]),_._v("。")],1),_._v(" "),e("h2",{attrs:{id:"_3、如何实现级联填充"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、如何实现级联填充"}},[_._v("#")]),_._v(" 3、如何实现级联填充？")]),_._v(" "),e("ul",[e("li",[_._v("在需要按顺序执行的属性上添加 "),e("code",[_._v("@Order")]),_._v(" 注解（Spring 环境），或直接在 "),e("code",[_._v("@AssembleXXX")]),_._v(" 注解的 "),e("code",[_._v("sort")]),_._v(" 属性指定排序值，越小越先执行；")]),_._v(" "),e("li",[_._v("在指定操作顺序的前提下，使用有序的装配执行器 "),e("code",[_._v("OrderedBeanOperationExecutor")]),_._v(" 完成对目标的填充操作；")])]),_._v(" "),e("p",[_._v("具体参见 "),e("RouterLink",{attrs:{to:"/operation/3.6.操作排序.html"}},[_._v("操作排序")]),_._v("。")],1),_._v(" "),e("h2",{attrs:{id:"_4、如何处理一对多的情况"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、如何处理一对多的情况"}},[_._v("#")]),_._v(" 4、如何处理一对多的情况？")]),_._v(" "),e("p",[_._v("通过 "),e("code",[_._v("@AssembleXXX")]),_._v(" 注解中的 "),e("code",[_._v("handler")]),_._v(" 或 "),e("code",[_._v("handlerType")]),_._v(" 属性指定装配处理器为一对多装配处理器 "),e("code",[_._v("OneToManyAssembleOperationHandler")]),_._v(" 类型或名称（在 spring 中即为 bean 名称）即可。")]),_._v(" "),e("p",[_._v("具体参见 "),e("RouterLink",{attrs:{to:"/operation/3.3.指定装配处理器.html"}},[_._v("指定装配处理器")]),_._v(" 中一对多装配一节。")],1),_._v(" "),e("h2",{attrs:{id:"_5、键字段可以是按分隔符拼接的字符串吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5、键字段可以是按分隔符拼接的字符串吗"}},[_._v("#")]),_._v(" 5、键字段可以是按分隔符拼接的字符串吗？")]),_._v(" "),e("p",[_._v("通过 "),e("code",[_._v("@AssembleXXX")]),_._v(" 注解中的 "),e("code",[_._v("handler")]),_._v(" 或 "),e("code",[_._v("handlerType")]),_._v(" 属性指定装配处理器为一对多装配处理器 "),e("code",[_._v("ManyToManyAssembleOperationHandler")]),_._v(" 的类型或名称（在 spring 中即为 bean 名称）即可。")]),_._v(" "),e("p",[_._v("具体参见 "),e("RouterLink",{attrs:{to:"/operation/3.3.指定装配处理器.html"}},[_._v("指定装配处理器")]),_._v(" 中多对多装配一节。")],1),_._v(" "),e("h2",{attrs:{id:"_6、键字段可以是集合或者数组吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6、键字段可以是集合或者数组吗"}},[_._v("#")]),_._v(" 6、键字段可以是集合或者数组吗？")]),_._v(" "),e("p",[_._v("同上，通过 "),e("code",[_._v("@AssembleXXX")]),_._v(" 注解中的 "),e("code",[_._v("handler")]),_._v(" 或 "),e("code",[_._v("handlerType")]),_._v(" 属性指定装配处理器为一对多装配处理器 "),e("code",[_._v("ManyToManyAssembleOperationHandler")]),_._v(" 的类型或名称（在 spring 中即为 bean 名称）即可。")]),_._v(" "),e("p",[_._v("具体参见 "),e("RouterLink",{attrs:{to:"/operation/3.3.指定装配处理器.html"}},[_._v("指定装配处理器")]),_._v(" 中多对多装配一节。")],1),_._v(" "),e("h2",{attrs:{id:"_7、为什么使用异步执行器的时候报错"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7、为什么使用异步执行器的时候报错"}},[_._v("#")]),_._v(" 7、为什么使用异步执行器的时候报错？")]),_._v(" "),e("p",[_._v("默认情况下，并没有注册异步操作执行器 "),e("code",[_._v("AsyncBeanOperationExecutor")]),_._v("，用户需要自行创建后再将其注册到全局配置中。")]),_._v(" "),e("p",[_._v("具体参见 "),e("RouterLink",{attrs:{to:"/execute/4.3.操作执行器.html"}},[_._v("操作执行器")]),_._v(" 一节。")],1),_._v(" "),e("h2",{attrs:{id:"_8、怎么刷新容器的数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8、怎么刷新容器的数据"}},[_._v("#")]),_._v(" 8、怎么刷新容器的数据 ？")]),_._v(" "),e("ul",[e("li",[_._v("如果容器是 "),e("code",[_._v("ConstantContainer")]),_._v(" ，直接通过 "),e("code",[_._v("get")]),_._v(" 方法获取缓存的 "),e("code",[_._v("Map")]),_._v(" 集合后直接修改即可；")]),_._v(" "),e("li",[_._v("获取 "),e("code",[_._v("Crane4jGlobalConfiguration")]),_._v(" 或 "),e("code",[_._v("ContainerManager")]),_._v(" 后，通过 "),e("code",[_._v("registerContainer")]),_._v(" 使用命名空间相同的容器对旧容器进行覆盖；")])]),_._v(" "),e("h2",{attrs:{id:"_9、怎么忽略掉某些字段不进行填充"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9、怎么忽略掉某些字段不进行填充"}},[_._v("#")]),_._v(" 9、怎么忽略掉某些字段不进行填充？")]),_._v(" "),e("ul",[e("li",[_._v("使用 "),e("code",[_._v("@AssembleXXX")]),_._v(" 注解的 "),e("code",[_._v("groups")]),_._v(" 属性对指定操作进行分组；")]),_._v(" "),e("li",[_._v("在配置了分组的前提下，在使用 "),e("code",[_._v("OperateTemplate")]),_._v(" 手动填充，或通过被 "),e("code",[_._v("@AutoOperate")]),_._v(" 注解的方法进行自动填充时，指定仅执行/仅不执行特定分组的操作；")])]),_._v(" "),e("p",[_._v("具体参见 "),e("RouterLink",{attrs:{to:"/operation/3.5.操作分组.html"}},[_._v("操作分组")]),_._v(" 一节。")],1),_._v(" "),e("h2",{attrs:{id:"_10、为什么-containermethod-注解不生效"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10、为什么-containermethod-注解不生效"}},[_._v("#")]),_._v(" 10、为什么 "),e("code",[_._v("@ContainerMethod")]),_._v(" 注解不生效？")]),_._v(" "),e("p",[_._v("如果是非 spring 环境，则需要手动的通过 "),e("code",[_._v("ContainerMethodAnnotationProcessor")]),_._v(" 扫描指定类并向全局配置注册扫描获取的方法容器。")]),_._v(" "),e("p",[_._v("如果是 spring 环境，请确保：")]),_._v(" "),e("ul",[e("li",[_._v("容器中存在 "),e("code",[_._v("BeanMethodContainerRegistrar")]),_._v(" 后处理器；")]),_._v(" "),e("li",[_._v("被注解的方法所在类被 Spring 扫描，且容器中存在对应的 bean；")]),_._v(" "),e("li",[_._v("被注解的方法所在类在 "),e("code",[_._v("BeanMethodContainerRegistrar")]),_._v(" 后处理器初始化后才加载；")])]),_._v(" "),e("h2",{attrs:{id:"_11、为什么-autooperate-注解不生效"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11、为什么-autooperate-注解不生效"}},[_._v("#")]),_._v(" 11、为什么 "),e("code",[_._v("@AutoOperate")]),_._v(" 注解不生效？")]),_._v(" "),e("p",[_._v("如果是非 spring 环境，则需要手动的通过 "),e("code",[_._v("MethodArgumentAutoOperateSupport")]),_._v(" 和 "),e("code",[_._v("MethodResultAutoOperateSupport")]),_._v(" 拦截方法调用。")]),_._v(" "),e("p",[_._v("如果是 spring 环境，请确保：")]),_._v(" "),e("ul",[e("li",[_._v("开启了 "),e("code",[_._v("SpringAOP")]),_._v(" 功能；")]),_._v(" "),e("li",[_._v("容器中存在 "),e("code",[_._v("MethodResultAutoOperateAdvisor")]),_._v(" 或 "),e("code",[_._v("MethodArgumentAutoOperateAdvisor")]),_._v(" 通知器；")]),_._v(" "),e("li",[_._v("被注解的方法所在类被 Spring 扫描、容器中存在对应的 bean 且被 Spring 代理；")])]),_._v(" "),e("h2",{attrs:{id:"_12、为什么引了-guava-和-hutool"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12、为什么引了-guava-和-hutool"}},[_._v("#")]),_._v(" 12、为什么引了 guava 和 hutool ？")]),_._v(" "),e("p",[_._v("不想要重复造轮子，有些组件直接使用成熟的开源库比自己再写一套更可靠。")]),_._v(" "),e("p",[_._v("此外，"),e("code",[_._v("crane4j")]),_._v(" 仅在有限的地方使用了这些工具类库：")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("guava")]),_._v(" ：使用了缓存组件 "),e("code",[_._v("Cache")]),_._v(" 与用于构造 "),e("code",[_._v("WeakConcurrentMap")]),_._v(" 的  "),e("code",[_._v("MapMaker")]),_._v("；")]),_._v(" "),e("li",[e("code",[_._v("hutool")]),_._v("：使用了类型转换取组件 "),e("code",[_._v("Convert")]),_._v("，如果没用到 "),e("code",[_._v("HutoolConverterManager")]),_._v(" 可以在依赖中排除；")])]),_._v(" "),e("h2",{attrs:{id:"_13、支持-jdk9-springboot3-吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_13、支持-jdk9-springboot3-吗"}},[_._v("#")]),_._v(" 13、支持 jdk9+ / springboot3 吗？")]),_._v(" "),e("p",[_._v("在 "),e("code",[_._v("jdk11")]),_._v(" 与 "),e("code",[_._v("jdk17")]),_._v(" 和相应版本 springboot 中测试后可以正常运行。")]),_._v(" "),e("h2",{attrs:{id:"_14、容器可以做一些自定义的初始化-销毁操作吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_14、容器可以做一些自定义的初始化-销毁操作吗"}},[_._v("#")]),_._v(" 14、容器可以做一些自定义的初始化/销毁操作吗？")]),_._v(" "),e("p",[_._v("实现 "),e("code",[_._v("Container.Lifecycle")]),_._v(" 接口即可，具体参见 "),e("RouterLink",{attrs:{to:"/advance/5.3.容器的生命周期回调.html"}},[_._v("容器的生命周期回调")]),_._v("。")],1),_._v(" "),e("h2",{attrs:{id:"_15、可以支持同时根据多个-key-字段填充数据吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_15、可以支持同时根据多个-key-字段填充数据吗"}},[_._v("#")]),_._v(" 15、可以支持同时根据多个 key 字段填充数据吗？")]),_._v(" "),e("p",[_._v("可以，不过实现方式有点特殊，具体参照 "),e("RouterLink",{attrs:{to:"/container/2.9.对象容器.html"}},[_._v("对象容器")]),_._v("。")],1)])}),[],!1,null,null,null);e.default=a.exports}}]);