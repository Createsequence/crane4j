## 概述

在默认情况下，`Container` 总是用于根据指定的 key 值查询对应的数据源，但是在有些情况下，我们可能需要同时根据多个 key 值，或一些复杂的自定义条件确认一个与待处理对象唯一对应的数据源对象。

为此，`crane4j` 支持直接将待填充的对象直接作为 key 值传入容器，由用户自行决定要如何返回数据源，此类容器称为“**对象容器**”。

对象容器可以是任何类型的容器，只要它**接受待处理对象本身，并且返回以待填充对象本身分组的数据源对象集合**即可。

## 使用

比如，我们现有待填充对象 `Foo`：

~~~java
@Assemble(container = "foo_info") // 直接以当前的 Foo 对象作为 key，去数据源容器中查询
@Data
public class Foo {
    private Integer id;
    private String code;
    private String name;
}
~~~

我们需要根据 id 和 code 去确认一个对应的 name，此时，我们直接在类上添加 `@Assemble` 注解而不指定任何的 key 值，那么该装配操作执行时，将直接把待填充的 `Foo` 对象作为 key 值传入命名空间为 `foo_info` 容器中。

~~~java
public Map<Foo, FooInfo> selectFooInfo(Collection<Foo> foos) {
    // 根据 foo 的 id 和 code 查询对应的 FooInfo 对象，并按 Foo 实例分组
}

// 构建对象容器
Container<Foo> objectContainer = Containers.forLambda("foo_info", foos -> {
    Map<Foo, FooInfo> data = selectFooInfo(foos);
});

// 获取全局上下文并注册容器
Crane4jGlobalConfiguration configuration = SpringUtils.getBean(Crane4jGlobalConfiguration.class);
configuration.registerContainer(objectContainer);
~~~

这里需要注意的是，`Container` 返回的数据必须按**入参的对象实例本身**分组，如果重写了 `equals` 或者 `hashCode` 需要格外注意。
